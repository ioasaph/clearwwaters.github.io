<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/sucrase/dist/parser/plugins/typescript.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node_modules/sucrase/dist/parser/plugins/typescript.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";Object.defineProperty(exports, "__esModule", {value: true});








var _index = require('../tokenizer/index');
var _keywords = require('../tokenizer/keywords');
var _types = require('../tokenizer/types');
var _base = require('../traverser/base');















var _expression = require('../traverser/expression');
var _lval = require('../traverser/lval');











var _statement = require('../traverser/statement');











var _util = require('../traverser/util');
var _jsx = require('./jsx');

function tsIsIdentifier() {
  // TODO: actually a bit more complex in TypeScript, but shouldn't matter.
  // See https://github.com/Microsoft/TypeScript/issues/15008
  return _index.match.call(void 0, _types.TokenType.name);
}

function isLiteralPropertyName() {
  return (
    _index.match.call(void 0, _types.TokenType.name) ||
    Boolean(_base.state.type &amp; _types.TokenType.IS_KEYWORD) ||
    _index.match.call(void 0, _types.TokenType.string) ||
    _index.match.call(void 0, _types.TokenType.num) ||
    _index.match.call(void 0, _types.TokenType.bigint) ||
    _index.match.call(void 0, _types.TokenType.decimal)
  );
}

function tsNextTokenCanFollowModifier() {
  // Note: TypeScript's implementation is much more complicated because
  // more things are considered modifiers there.
  // This implementation only handles modifiers not handled by babylon itself. And "static".
  // TODO: Would be nice to avoid lookahead. Want a hasLineBreakUpNext() method...
  const snapshot = _base.state.snapshot();

  _index.next.call(void 0, );
  const canFollowModifier =
    (_index.match.call(void 0, _types.TokenType.bracketL) ||
      _index.match.call(void 0, _types.TokenType.braceL) ||
      _index.match.call(void 0, _types.TokenType.star) ||
      _index.match.call(void 0, _types.TokenType.ellipsis) ||
      _index.match.call(void 0, _types.TokenType.hash) ||
      isLiteralPropertyName()) &amp;&amp;
    !_util.hasPrecedingLineBreak.call(void 0, );

  if (canFollowModifier) {
    return true;
  } else {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  }
}

/** Parses a modifier matching one the given modifier names. */
 function tsParseModifier(
  allowedModifiers,
) {
  if (!_index.match.call(void 0, _types.TokenType.name)) {
    return null;
  }

  const modifier = _base.state.contextualKeyword;
  if (allowedModifiers.indexOf(modifier) !== -1 &amp;&amp; tsNextTokenCanFollowModifier()) {
    switch (modifier) {
      case _keywords.ContextualKeyword._readonly:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._readonly;
        break;
      case _keywords.ContextualKeyword._abstract:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
        break;
      case _keywords.ContextualKeyword._static:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._static;
        break;
      case _keywords.ContextualKeyword._public:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._public;
        break;
      case _keywords.ContextualKeyword._private:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._private;
        break;
      case _keywords.ContextualKeyword._protected:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._protected;
        break;
      case _keywords.ContextualKeyword._declare:
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
        break;
      default:
        break;
    }
    return modifier;
  }
  return null;
} exports.tsParseModifier = tsParseModifier;

function tsParseEntityName() {
  _expression.parseIdentifier.call(void 0, );
  while (_index.eat.call(void 0, _types.TokenType.dot)) {
    _expression.parseIdentifier.call(void 0, );
  }
}

function tsParseTypeReference() {
  tsParseEntityName();
  if (!_util.hasPrecedingLineBreak.call(void 0, ) &amp;&amp; _index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseThisTypePredicate() {
  _index.next.call(void 0, );
  tsParseTypeAnnotation();
}

function tsParseThisTypeNode() {
  _index.next.call(void 0, );
}

function tsParseTypeQuery() {
  _util.expect.call(void 0, _types.TokenType._typeof);
  if (_index.match.call(void 0, _types.TokenType._import)) {
    tsParseImportType();
  } else {
    tsParseEntityName();
  }
}

function tsParseImportType() {
  _util.expect.call(void 0, _types.TokenType._import);
  _util.expect.call(void 0, _types.TokenType.parenL);
  _util.expect.call(void 0, _types.TokenType.string);
  _util.expect.call(void 0, _types.TokenType.parenR);
  if (_index.eat.call(void 0, _types.TokenType.dot)) {
    tsParseEntityName();
  }
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseTypeParameter() {
  _expression.parseIdentifier.call(void 0, );
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    tsParseType();
  }
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    tsParseType();
  }
}

 function tsTryParseTypeParameters() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeParameters();
  }
} exports.tsTryParseTypeParameters = tsTryParseTypeParameters;

function tsParseTypeParameters() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  if (_index.match.call(void 0, _types.TokenType.lessThan) || _index.match.call(void 0, _types.TokenType.typeParameterStart)) {
    _index.next.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }

  while (!_index.eat.call(void 0, _types.TokenType.greaterThan) &amp;&amp; !_base.state.error) {
    tsParseTypeParameter();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

// Note: In TypeScript implementation we must provide `yieldContext` and `awaitContext`,
// but here it's always false, because this is only used for types.
function tsFillSignature(returnToken) {
  // Arrow fns *must* have return token (`=>`). Normal functions can omit it.
  const returnTokenRequired = returnToken === _types.TokenType.arrow;
  tsTryParseTypeParameters();
  _util.expect.call(void 0, _types.TokenType.parenL);
  // Create a scope even though we're doing type parsing so we don't accidentally
  // treat params as top-level bindings.
  _base.state.scopeDepth++;
  tsParseBindingListForSignature(false /* isBlockScope */);
  _base.state.scopeDepth--;
  if (returnTokenRequired) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  } else if (_index.match.call(void 0, returnToken)) {
    tsParseTypeOrTypePredicateAnnotation(returnToken);
  }
}

function tsParseBindingListForSignature(isBlockScope) {
  _lval.parseBindingList.call(void 0, _types.TokenType.parenR, isBlockScope);
}

function tsParseTypeMemberSemicolon() {
  if (!_index.eat.call(void 0, _types.TokenType.comma)) {
    _util.semicolon.call(void 0, );
  }
}

function tsParseSignatureMember() {
  tsFillSignature(_types.TokenType.colon);
  tsParseTypeMemberSemicolon();
}

function tsIsUnambiguouslyIndexSignature() {
  const snapshot = _base.state.snapshot();
  _index.next.call(void 0, ); // Skip '{'
  const isIndexSignature = _index.eat.call(void 0, _types.TokenType.name) &amp;&amp; _index.match.call(void 0, _types.TokenType.colon);
  _base.state.restoreFromSnapshot(snapshot);
  return isIndexSignature;
}

function tsTryParseIndexSignature() {
  if (!(_index.match.call(void 0, _types.TokenType.bracketL) &amp;&amp; tsIsUnambiguouslyIndexSignature())) {
    return false;
  }

  const oldIsType = _index.pushTypeContext.call(void 0, 0);

  _util.expect.call(void 0, _types.TokenType.bracketL);
  _expression.parseIdentifier.call(void 0, );
  tsParseTypeAnnotation();
  _util.expect.call(void 0, _types.TokenType.bracketR);

  tsTryParseTypeAnnotation();
  tsParseTypeMemberSemicolon();

  _index.popTypeContext.call(void 0, oldIsType);
  return true;
}

function tsParsePropertyOrMethodSignature(isReadonly) {
  _index.eat.call(void 0, _types.TokenType.question);

  if (!isReadonly &amp;&amp; (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan))) {
    tsFillSignature(_types.TokenType.colon);
    tsParseTypeMemberSemicolon();
  } else {
    tsTryParseTypeAnnotation();
    tsParseTypeMemberSemicolon();
  }
}

function tsParseTypeMember() {
  if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
    // call signature
    tsParseSignatureMember();
    return;
  }
  if (_index.match.call(void 0, _types.TokenType._new)) {
    _index.next.call(void 0, );
    if (_index.match.call(void 0, _types.TokenType.parenL) || _index.match.call(void 0, _types.TokenType.lessThan)) {
      // constructor signature
      tsParseSignatureMember();
    } else {
      tsParsePropertyOrMethodSignature(false);
    }
    return;
  }
  const readonly = !!tsParseModifier([_keywords.ContextualKeyword._readonly]);

  const found = tsTryParseIndexSignature();
  if (found) {
    return;
  }
  _expression.parsePropertyName.call(void 0, -1 /* Types don't need context IDs. */);
  tsParsePropertyOrMethodSignature(readonly);
}

function tsParseTypeLiteral() {
  tsParseObjectTypeMembers();
}

function tsParseObjectTypeMembers() {
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.eat.call(void 0, _types.TokenType.braceR) &amp;&amp; !_base.state.error) {
    tsParseTypeMember();
  }
}

function tsLookaheadIsStartOfMappedType() {
  const snapshot = _base.state.snapshot();
  const isStartOfMappedType = tsIsStartOfMappedType();
  _base.state.restoreFromSnapshot(snapshot);
  return isStartOfMappedType;
}

function tsIsStartOfMappedType() {
  _index.next.call(void 0, );
  if (_index.eat.call(void 0, _types.TokenType.plus) || _index.eat.call(void 0, _types.TokenType.minus)) {
    return _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly);
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)) {
    _index.next.call(void 0, );
  }
  if (!_index.match.call(void 0, _types.TokenType.bracketL)) {
    return false;
  }
  _index.next.call(void 0, );
  if (!tsIsIdentifier()) {
    return false;
  }
  _index.next.call(void 0, );
  return _index.match.call(void 0, _types.TokenType._in);
}

function tsParseMappedTypeParameter() {
  _expression.parseIdentifier.call(void 0, );
  _util.expect.call(void 0, _types.TokenType._in);
  tsParseType();
}

function tsParseMappedType() {
  _util.expect.call(void 0, _types.TokenType.braceL);
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0, );
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._readonly);
  } else {
    _util.eatContextual.call(void 0, _keywords.ContextualKeyword._readonly);
  }
  _util.expect.call(void 0, _types.TokenType.bracketL);
  tsParseMappedTypeParameter();
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    tsParseType();
  }
  _util.expect.call(void 0, _types.TokenType.bracketR);
  if (_index.match.call(void 0, _types.TokenType.plus) || _index.match.call(void 0, _types.TokenType.minus)) {
    _index.next.call(void 0, );
    _util.expect.call(void 0, _types.TokenType.question);
  } else {
    _index.eat.call(void 0, _types.TokenType.question);
  }
  tsTryParseType();
  _util.semicolon.call(void 0, );
  _util.expect.call(void 0, _types.TokenType.braceR);
}

function tsParseTupleType() {
  _util.expect.call(void 0, _types.TokenType.bracketL);
  while (!_index.eat.call(void 0, _types.TokenType.bracketR) &amp;&amp; !_base.state.error) {
    // Do not validate presence of either none or only labeled elements
    tsParseTupleElementType();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
}

function tsParseTupleElementType() {
  // parses `...TsType[]`
  if (_index.eat.call(void 0, _types.TokenType.ellipsis)) {
    tsParseType();
  } else {
    // parses `TsType?`
    tsParseType();
    _index.eat.call(void 0, _types.TokenType.question);
  }

  // The type we parsed above was actually a label
  if (_index.eat.call(void 0, _types.TokenType.colon)) {
    // Labeled tuple types must affix the label with `...` or `?`, so no need to handle those here
    tsParseType();
  }
}

function tsParseParenthesizedType() {
  _util.expect.call(void 0, _types.TokenType.parenL);
  tsParseType();
  _util.expect.call(void 0, _types.TokenType.parenR);
}

function tsParseTemplateLiteralType() {
  // Finish `, read quasi
  _index.nextTemplateToken.call(void 0, );
  // Finish quasi, read ${
  _index.nextTemplateToken.call(void 0, );
  while (!_index.match.call(void 0, _types.TokenType.backQuote) &amp;&amp; !_base.state.error) {
    _util.expect.call(void 0, _types.TokenType.dollarBraceL);
    tsParseType();
    // Finish }, read quasi
    _index.nextTemplateToken.call(void 0, );
    // Finish quasi, read either ${ or `
    _index.nextTemplateToken.call(void 0, );
  }
  _index.next.call(void 0, );
}

var FunctionType; (function (FunctionType) {
  const TSFunctionType = 0; FunctionType[FunctionType["TSFunctionType"] = TSFunctionType] = "TSFunctionType";
  const TSConstructorType = TSFunctionType + 1; FunctionType[FunctionType["TSConstructorType"] = TSConstructorType] = "TSConstructorType";
})(FunctionType || (FunctionType = {}));

function tsParseFunctionOrConstructorType(type) {
  if (type === FunctionType.TSConstructorType) {
    _util.expect.call(void 0, _types.TokenType._new);
  }
  tsFillSignature(_types.TokenType.arrow);
}

function tsParseNonArrayType() {
  switch (_base.state.type) {
    case _types.TokenType.name:
      tsParseTypeReference();
      return;
    case _types.TokenType._void:
    case _types.TokenType._null:
      _index.next.call(void 0, );
      return;
    case _types.TokenType.string:
    case _types.TokenType.num:
    case _types.TokenType.bigint:
    case _types.TokenType.decimal:
    case _types.TokenType._true:
    case _types.TokenType._false:
      _expression.parseLiteral.call(void 0, );
      return;
    case _types.TokenType.minus:
      _index.next.call(void 0, );
      _expression.parseLiteral.call(void 0, );
      return;
    case _types.TokenType._this: {
      tsParseThisTypeNode();
      if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) &amp;&amp; !_util.hasPrecedingLineBreak.call(void 0, )) {
        tsParseThisTypePredicate();
      }
      return;
    }
    case _types.TokenType._typeof:
      tsParseTypeQuery();
      return;
    case _types.TokenType._import:
      tsParseImportType();
      return;
    case _types.TokenType.braceL:
      if (tsLookaheadIsStartOfMappedType()) {
        tsParseMappedType();
      } else {
        tsParseTypeLiteral();
      }
      return;
    case _types.TokenType.bracketL:
      tsParseTupleType();
      return;
    case _types.TokenType.parenL:
      tsParseParenthesizedType();
      return;
    case _types.TokenType.backQuote:
      tsParseTemplateLiteralType();
      return;
    default:
      if (_base.state.type &amp; _types.TokenType.IS_KEYWORD) {
        _index.next.call(void 0, );
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.name;
        return;
      }
      break;
  }

  _util.unexpected.call(void 0, );
}

function tsParseArrayTypeOrHigher() {
  tsParseNonArrayType();
  while (!_util.hasPrecedingLineBreak.call(void 0, ) &amp;&amp; _index.eat.call(void 0, _types.TokenType.bracketL)) {
    if (!_index.eat.call(void 0, _types.TokenType.bracketR)) {
      // If we hit ] immediately, this is an array type, otherwise it's an indexed access type.
      tsParseType();
      _util.expect.call(void 0, _types.TokenType.bracketR);
    }
  }
}

function tsParseInferType() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._infer);
  _expression.parseIdentifier.call(void 0, );
}

function tsParseTypeOperatorOrHigher() {
  if (
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._keyof) ||
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._unique) ||
    _util.isContextual.call(void 0, _keywords.ContextualKeyword._readonly)
  ) {
    _index.next.call(void 0, );
    tsParseTypeOperatorOrHigher();
  } else if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._infer)) {
    tsParseInferType();
  } else {
    tsParseArrayTypeOrHigher();
  }
}

function tsParseIntersectionTypeOrHigher() {
  _index.eat.call(void 0, _types.TokenType.bitwiseAND);
  tsParseTypeOperatorOrHigher();
  if (_index.match.call(void 0, _types.TokenType.bitwiseAND)) {
    while (_index.eat.call(void 0, _types.TokenType.bitwiseAND)) {
      tsParseTypeOperatorOrHigher();
    }
  }
}

function tsParseUnionTypeOrHigher() {
  _index.eat.call(void 0, _types.TokenType.bitwiseOR);
  tsParseIntersectionTypeOrHigher();
  if (_index.match.call(void 0, _types.TokenType.bitwiseOR)) {
    while (_index.eat.call(void 0, _types.TokenType.bitwiseOR)) {
      tsParseIntersectionTypeOrHigher();
    }
  }
}

function tsIsStartOfFunctionType() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    return true;
  }
  return _index.match.call(void 0, _types.TokenType.parenL) &amp;&amp; tsLookaheadIsUnambiguouslyStartOfFunctionType();
}

function tsSkipParameterStart() {
  if (_index.match.call(void 0, _types.TokenType.name) || _index.match.call(void 0, _types.TokenType._this)) {
    _index.next.call(void 0, );
    return true;
  }
  // If this is a possible array/object destructure, walk to the matching bracket/brace.
  // The next token after will tell us definitively whether this is a function param.
  if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {
    let depth = 1;
    _index.next.call(void 0, );
    while (depth > 0 &amp;&amp; !_base.state.error) {
      if (_index.match.call(void 0, _types.TokenType.braceL) || _index.match.call(void 0, _types.TokenType.bracketL)) {
        depth++;
      } else if (_index.match.call(void 0, _types.TokenType.braceR) || _index.match.call(void 0, _types.TokenType.bracketR)) {
        depth--;
      }
      _index.next.call(void 0, );
    }
    return true;
  }
  return false;
}

function tsLookaheadIsUnambiguouslyStartOfFunctionType() {
  const snapshot = _base.state.snapshot();
  const isUnambiguouslyStartOfFunctionType = tsIsUnambiguouslyStartOfFunctionType();
  _base.state.restoreFromSnapshot(snapshot);
  return isUnambiguouslyStartOfFunctionType;
}

function tsIsUnambiguouslyStartOfFunctionType() {
  _index.next.call(void 0, );
  if (_index.match.call(void 0, _types.TokenType.parenR) || _index.match.call(void 0, _types.TokenType.ellipsis)) {
    // ( )
    // ( ...
    return true;
  }
  if (tsSkipParameterStart()) {
    if (_index.match.call(void 0, _types.TokenType.colon) || _index.match.call(void 0, _types.TokenType.comma) || _index.match.call(void 0, _types.TokenType.question) || _index.match.call(void 0, _types.TokenType.eq)) {
      // ( xxx :
      // ( xxx ,
      // ( xxx ?
      // ( xxx =
      return true;
    }
    if (_index.match.call(void 0, _types.TokenType.parenR)) {
      _index.next.call(void 0, );
      if (_index.match.call(void 0, _types.TokenType.arrow)) {
        // ( xxx ) =>
        return true;
      }
    }
  }
  return false;
}

function tsParseTypeOrTypePredicateAnnotation(returnToken) {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, returnToken);
  const finishedReturn = tsParseTypePredicateOrAssertsPrefix();
  if (!finishedReturn) {
    tsParseType();
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

function tsTryParseTypeOrTypePredicateAnnotation() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
  }
}

 function tsTryParseTypeAnnotation() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeAnnotation();
  }
} exports.tsTryParseTypeAnnotation = tsTryParseTypeAnnotation;

function tsTryParseType() {
  if (_index.eat.call(void 0, _types.TokenType.colon)) {
    tsParseType();
  }
}

/**
 * Detect a few special return syntax cases: `x is T`, `asserts x`, `asserts x is T`,
 * `asserts this is T`.
 *
 * Returns true if we parsed the return type, false if there's still a type to be parsed.
 */
function tsParseTypePredicateOrAssertsPrefix() {
  const snapshot = _base.state.snapshot();
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._asserts) &amp;&amp; !_util.hasPrecedingLineBreak.call(void 0, )) {
    // Normally this is `asserts x is T`, but at this point, it might be `asserts is T` (a user-
    // defined type guard on the `asserts` variable) or just a type called `asserts`.
    _index.next.call(void 0, );
    if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {
      // If we see `asserts is`, then this must be of the form `asserts is T`, since
      // `asserts is is T` isn't valid.
      tsParseType();
      return true;
    } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {
      _index.next.call(void 0, );
      if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._is)) {
        // If we see `is`, then this is `asserts x is T`. Otherwise, it's `asserts x`.
        tsParseType();
      }
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      _base.state.restoreFromSnapshot(snapshot);
      return false;
    }
  } else if (tsIsIdentifier() || _index.match.call(void 0, _types.TokenType._this)) {
    // This is a regular identifier, which may or may not have "is" after it.
    _index.next.call(void 0, );
    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._is) &amp;&amp; !_util.hasPrecedingLineBreak.call(void 0, )) {
      _index.next.call(void 0, );
      tsParseType();
      return true;
    } else {
      // Regular type, so bail out and start type parsing from scratch.
      _base.state.restoreFromSnapshot(snapshot);
      return false;
    }
  }
  return false;
}

 function tsParseTypeAnnotation() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.colon);
  tsParseType();
  _index.popTypeContext.call(void 0, oldIsType);
} exports.tsParseTypeAnnotation = tsParseTypeAnnotation;

 function tsParseType() {
  tsParseNonConditionalType();
  if (_util.hasPrecedingLineBreak.call(void 0, ) || !_index.eat.call(void 0, _types.TokenType._extends)) {
    return;
  }
  // extends type
  tsParseNonConditionalType();
  _util.expect.call(void 0, _types.TokenType.question);
  // true type
  tsParseType();
  _util.expect.call(void 0, _types.TokenType.colon);
  // false type
  tsParseType();
} exports.tsParseType = tsParseType;

 function tsParseNonConditionalType() {
  if (tsIsStartOfFunctionType()) {
    tsParseFunctionOrConstructorType(FunctionType.TSFunctionType);
    return;
  }
  if (_index.match.call(void 0, _types.TokenType._new)) {
    // As in `new () => Date`
    tsParseFunctionOrConstructorType(FunctionType.TSConstructorType);
    return;
  }
  tsParseUnionTypeOrHigher();
} exports.tsParseNonConditionalType = tsParseNonConditionalType;

 function tsParseTypeAssertion() {
  const oldIsType = _index.pushTypeContext.call(void 0, 1);
  tsParseType();
  _util.expect.call(void 0, _types.TokenType.greaterThan);
  _index.popTypeContext.call(void 0, oldIsType);
  _expression.parseMaybeUnary.call(void 0, );
} exports.tsParseTypeAssertion = tsParseTypeAssertion;

 function tsTryParseJSXTypeArgument() {
  if (_index.eat.call(void 0, _types.TokenType.jsxTagStart)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.typeParameterStart;
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    while (!_index.match.call(void 0, _types.TokenType.greaterThan) &amp;&amp; !_base.state.error) {
      tsParseType();
      _index.eat.call(void 0, _types.TokenType.comma);
    }
    // Process >, but the one after needs to be parsed JSX-style.
    _jsx.nextJSXTagToken.call(void 0, );
    _index.popTypeContext.call(void 0, oldIsType);
  }
} exports.tsTryParseJSXTypeArgument = tsTryParseJSXTypeArgument;

function tsParseHeritageClause() {
  while (!_index.match.call(void 0, _types.TokenType.braceL) &amp;&amp; !_base.state.error) {
    tsParseExpressionWithTypeArguments();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
}

function tsParseExpressionWithTypeArguments() {
  // Note: TS uses parseLeftHandSideExpressionOrHigher,
  // then has grammar errors later if it's not an EntityName.
  tsParseEntityName();
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
}

function tsParseInterfaceDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  tsTryParseTypeParameters();
  if (_index.eat.call(void 0, _types.TokenType._extends)) {
    tsParseHeritageClause();
  }
  tsParseObjectTypeMembers();
}

function tsParseTypeAliasDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  tsTryParseTypeParameters();
  _util.expect.call(void 0, _types.TokenType.eq);
  tsParseType();
  _util.semicolon.call(void 0, );
}

function tsParseEnumMember() {
  // Computed property names are grammar errors in an enum, so accept just string literal or identifier.
  if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseLiteral.call(void 0, );
  } else {
    _expression.parseIdentifier.call(void 0, );
  }
  if (_index.eat.call(void 0, _types.TokenType.eq)) {
    const eqIndex = _base.state.tokens.length - 1;
    _expression.parseMaybeAssign.call(void 0, );
    _base.state.tokens[eqIndex].rhsEndIndex = _base.state.tokens.length;
  }
}

function tsParseEnumDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  _util.expect.call(void 0, _types.TokenType.braceL);
  while (!_index.eat.call(void 0, _types.TokenType.braceR) &amp;&amp; !_base.state.error) {
    tsParseEnumMember();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
}

function tsParseModuleBlock() {
  _util.expect.call(void 0, _types.TokenType.braceL);
  _statement.parseBlockBody.call(void 0, /* end */ _types.TokenType.braceR);
}

function tsParseModuleOrNamespaceDeclaration() {
  _lval.parseBindingIdentifier.call(void 0, false);
  if (_index.eat.call(void 0, _types.TokenType.dot)) {
    tsParseModuleOrNamespaceDeclaration();
  } else {
    tsParseModuleBlock();
  }
}

function tsParseAmbientExternalModuleDeclaration() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._global)) {
    _expression.parseIdentifier.call(void 0, );
  } else if (_index.match.call(void 0, _types.TokenType.string)) {
    _expression.parseExprAtom.call(void 0, );
  } else {
    _util.unexpected.call(void 0, );
  }

  if (_index.match.call(void 0, _types.TokenType.braceL)) {
    tsParseModuleBlock();
  } else {
    _util.semicolon.call(void 0, );
  }
}

 function tsParseImportEqualsDeclaration() {
  _lval.parseImportedIdentifier.call(void 0, );
  _util.expect.call(void 0, _types.TokenType.eq);
  tsParseModuleReference();
  _util.semicolon.call(void 0, );
} exports.tsParseImportEqualsDeclaration = tsParseImportEqualsDeclaration;

function tsIsExternalModuleReference() {
  return _util.isContextual.call(void 0, _keywords.ContextualKeyword._require) &amp;&amp; _index.lookaheadType.call(void 0, ) === _types.TokenType.parenL;
}

function tsParseModuleReference() {
  if (tsIsExternalModuleReference()) {
    tsParseExternalModuleReference();
  } else {
    tsParseEntityName();
  }
}

function tsParseExternalModuleReference() {
  _util.expectContextual.call(void 0, _keywords.ContextualKeyword._require);
  _util.expect.call(void 0, _types.TokenType.parenL);
  if (!_index.match.call(void 0, _types.TokenType.string)) {
    _util.unexpected.call(void 0, );
  }
  _expression.parseLiteral.call(void 0, );
  _util.expect.call(void 0, _types.TokenType.parenR);
}

// Utilities

// Returns true if a statement matched.
function tsTryParseDeclare() {
  if (_util.isLineTerminator.call(void 0, )) {
    return false;
  }
  switch (_base.state.type) {
    case _types.TokenType._function: {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      _index.next.call(void 0, );
      // We don't need to precisely get the function start here, since it's only used to mark
      // the function as a type if it's bodiless, and it's already a type here.
      const functionStart = _base.state.start;
      _statement.parseFunction.call(void 0, functionStart, /* isStatement */ true);
      _index.popTypeContext.call(void 0, oldIsType);
      return true;
    }
    case _types.TokenType._class: {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      _statement.parseClass.call(void 0, /* isStatement */ true, /* optionalId */ false);
      _index.popTypeContext.call(void 0, oldIsType);
      return true;
    }
    case _types.TokenType._const: {
      if (_index.match.call(void 0, _types.TokenType._const) &amp;&amp; _util.isLookaheadContextual.call(void 0, _keywords.ContextualKeyword._enum)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        // `const enum = 0;` not allowed because "enum" is a strict mode reserved word.
        _util.expect.call(void 0, _types.TokenType._const);
        _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
        tsParseEnumDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
    }
    // falls through
    case _types.TokenType._var:
    case _types.TokenType._let: {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      _statement.parseVarStatement.call(void 0, _base.state.type);
      _index.popTypeContext.call(void 0, oldIsType);
      return true;
    }
    case _types.TokenType.name: {
      const oldIsType = _index.pushTypeContext.call(void 0, 1);
      const contextualKeyword = _base.state.contextualKeyword;
      let matched = false;
      if (contextualKeyword === _keywords.ContextualKeyword._global) {
        tsParseAmbientExternalModuleDeclaration();
        matched = true;
      } else {
        matched = tsParseDeclaration(contextualKeyword, /* isBeforeToken */ true);
      }
      _index.popTypeContext.call(void 0, oldIsType);
      return matched;
    }
    default:
      return false;
  }
}

// Note: this won't be called unless the keyword is allowed in `shouldParseExportDeclaration`.
// Returns true if it matched a declaration.
function tsTryParseExportDeclaration() {
  return tsParseDeclaration(_base.state.contextualKeyword, /* isBeforeToken */ true);
}

// Returns true if it matched a statement.
function tsParseExpressionStatement(contextualKeyword) {
  switch (contextualKeyword) {
    case _keywords.ContextualKeyword._declare: {
      const declareTokenIndex = _base.state.tokens.length - 1;
      const matched = tsTryParseDeclare();
      if (matched) {
        _base.state.tokens[declareTokenIndex].type = _types.TokenType._declare;
        return true;
      }
      break;
    }
    case _keywords.ContextualKeyword._global:
      // `global { }` (with no `declare`) may appear inside an ambient module declaration.
      // Would like to use tsParseAmbientExternalModuleDeclaration here, but already ran past "global".
      if (_index.match.call(void 0, _types.TokenType.braceL)) {
        tsParseModuleBlock();
        return true;
      }
      break;

    default:
      return tsParseDeclaration(contextualKeyword, /* isBeforeToken */ false);
  }
  return false;
}

// Common to tsTryParseDeclare, tsTryParseExportDeclaration, and tsParseExpressionStatement.
// Returns true if it matched a declaration.
function tsParseDeclaration(contextualKeyword, isBeforeToken) {
  switch (contextualKeyword) {
    case _keywords.ContextualKeyword._abstract:
      if (tsCheckLineTerminatorAndMatch(_types.TokenType._class, isBeforeToken)) {
        if (isBeforeToken) _index.next.call(void 0, );
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._abstract;
        _statement.parseClass.call(void 0, /* isStatement */ true, /* optionalId */ false);
        return true;
      }
      break;

    case _keywords.ContextualKeyword._enum:
      if (tsCheckLineTerminatorAndMatch(_types.TokenType.name, isBeforeToken)) {
        if (isBeforeToken) _index.next.call(void 0, );
        _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
        tsParseEnumDeclaration();
        return true;
      }
      break;

    case _keywords.ContextualKeyword._interface:
      if (tsCheckLineTerminatorAndMatch(_types.TokenType.name, isBeforeToken)) {
        // `next` is true in "export" and "declare" contexts, so we want to remove that token
        // as well.
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        if (isBeforeToken) _index.next.call(void 0, );
        tsParseInterfaceDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;

    case _keywords.ContextualKeyword._module:
      if (isBeforeToken) _index.next.call(void 0, );
      if (_index.match.call(void 0, _types.TokenType.string)) {
        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
        tsParseAmbientExternalModuleDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      } else if (tsCheckLineTerminatorAndMatch(_types.TokenType.name, isBeforeToken)) {
        const oldIsType = _index.pushTypeContext.call(void 0, isBeforeToken ? 2 : 1);
        if (isBeforeToken) _index.next.call(void 0, );
        tsParseModuleOrNamespaceDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;

    case _keywords.ContextualKeyword._namespace:
      if (tsCheckLineTerminatorAndMatch(_types.TokenType.name, isBeforeToken)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        if (isBeforeToken) _index.next.call(void 0, );
        tsParseModuleOrNamespaceDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;

    case _keywords.ContextualKeyword._type:
      if (tsCheckLineTerminatorAndMatch(_types.TokenType.name, isBeforeToken)) {
        const oldIsType = _index.pushTypeContext.call(void 0, 1);
        if (isBeforeToken) _index.next.call(void 0, );
        tsParseTypeAliasDeclaration();
        _index.popTypeContext.call(void 0, oldIsType);
        return true;
      }
      break;

    default:
      break;
  }
  return false;
}

function tsCheckLineTerminatorAndMatch(tokenType, isBeforeToken) {
  return !_util.isLineTerminator.call(void 0, ) &amp;&amp; (isBeforeToken || _index.match.call(void 0, tokenType));
}

// Returns true if there was a generic async arrow function.
function tsTryParseGenericAsyncArrowFunction() {
  const snapshot = _base.state.snapshot();

  tsParseTypeParameters();
  _statement.parseFunctionParams.call(void 0, );
  tsTryParseTypeOrTypePredicateAnnotation();
  _util.expect.call(void 0, _types.TokenType.arrow);

  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
    return false;
  }

  _expression.parseFunctionBody.call(void 0, true);
  return true;
}

function tsParseTypeArguments() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _util.expect.call(void 0, _types.TokenType.lessThan);
  while (!_index.eat.call(void 0, _types.TokenType.greaterThan) &amp;&amp; !_base.state.error) {
    tsParseType();
    _index.eat.call(void 0, _types.TokenType.comma);
  }
  _index.popTypeContext.call(void 0, oldIsType);
}

 function tsIsDeclarationStart() {
  if (_index.match.call(void 0, _types.TokenType.name)) {
    switch (_base.state.contextualKeyword) {
      case _keywords.ContextualKeyword._abstract:
      case _keywords.ContextualKeyword._declare:
      case _keywords.ContextualKeyword._enum:
      case _keywords.ContextualKeyword._interface:
      case _keywords.ContextualKeyword._module:
      case _keywords.ContextualKeyword._namespace:
      case _keywords.ContextualKeyword._type:
        return true;
      default:
        break;
    }
  }

  return false;
} exports.tsIsDeclarationStart = tsIsDeclarationStart;

// ======================================================
// OVERRIDES
// ======================================================

 function tsParseFunctionBodyAndFinish(functionStart, funcContextId) {
  // For arrow functions, `parseArrow` handles the return type itself.
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
  }

  // The original code checked the node type to make sure this function type allows a missing
  // body, but we skip that to avoid sending around the node type. We instead just use the
  // allowExpressionBody boolean to make sure it's not an arrow function.
  if (!_index.match.call(void 0, _types.TokenType.braceL) &amp;&amp; _util.isLineTerminator.call(void 0, )) {
    // Retroactively mark the function declaration as a type.
    let i = _base.state.tokens.length - 1;
    while (
      i >= 0 &amp;&amp;
      (_base.state.tokens[i].start >= functionStart ||
        _base.state.tokens[i].type === _types.TokenType._default ||
        _base.state.tokens[i].type === _types.TokenType._export)
    ) {
      _base.state.tokens[i].isType = true;
      i--;
    }
    return;
  }

  _expression.parseFunctionBody.call(void 0, false, funcContextId);
} exports.tsParseFunctionBodyAndFinish = tsParseFunctionBodyAndFinish;

 function tsParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (!_util.hasPrecedingLineBreak.call(void 0, ) &amp;&amp; _index.eat.call(void 0, _types.TokenType.bang)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType.nonNullAssertion;
    return;
  }

  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    // There are number of things we are going to "maybe" parse, like type arguments on
    // tagged template expressions. If any of them fail, walk it back and continue.
    const snapshot = _base.state.snapshot();

    if (!noCalls &amp;&amp; _expression.atPossibleAsync.call(void 0, )) {
      // Almost certainly this is a generic async function `async &lt;T>() => ...
      // But it might be a call with a type argument `async&lt;T>();`
      const asyncArrowFn = tsTryParseGenericAsyncArrowFunction();
      if (asyncArrowFn) {
        return;
      }
    }
    tsParseTypeArguments();
    if (!noCalls &amp;&amp; _index.eat.call(void 0, _types.TokenType.parenL)) {
      // With f&lt;T>(), the subscriptStartIndex marker is on the ( token.
      _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      _expression.parseCallExpressionArguments.call(void 0, );
    } else if (_index.match.call(void 0, _types.TokenType.backQuote)) {
      // Tagged template with a type argument.
      _expression.parseTemplate.call(void 0, );
    } else {
      _util.unexpected.call(void 0, );
    }

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    } else {
      return;
    }
  } else if (!noCalls &amp;&amp; _index.match.call(void 0, _types.TokenType.questionDot) &amp;&amp; _index.lookaheadType.call(void 0, ) === _types.TokenType.lessThan) {
    // If we see f?.&lt;, then this must be an optional call with a type argument.
    _index.next.call(void 0, );
    _base.state.tokens[startTokenIndex].isOptionalChainStart = true;
    // With f?.&lt;T>(), the subscriptStartIndex marker is on the ?. token.
    _base.state.tokens[_base.state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

    tsParseTypeArguments();
    _util.expect.call(void 0, _types.TokenType.parenL);
    _expression.parseCallExpressionArguments.call(void 0, );
  }
  _expression.baseParseSubscript.call(void 0, startTokenIndex, noCalls, stopState);
} exports.tsParseSubscript = tsParseSubscript;

 function tsStartParseNewArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    // 99% certain this is `new C&lt;T>();`. But may be `new C &lt; T;`, which is also legal.
    const snapshot = _base.state.snapshot();

    _base.state.type = _types.TokenType.typeParameterStart;
    tsParseTypeArguments();
    if (!_index.match.call(void 0, _types.TokenType.parenL)) {
      _util.unexpected.call(void 0, );
    }

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
} exports.tsStartParseNewArguments = tsStartParseNewArguments;

 function tsTryParseExport() {
  if (_index.match.call(void 0, _types.TokenType._import)) {
    // `export import A = B;`
    _util.expect.call(void 0, _types.TokenType._import);
    tsParseImportEqualsDeclaration();
    return true;
  } else if (_index.eat.call(void 0, _types.TokenType.eq)) {
    // `export = x;`
    _expression.parseExpression.call(void 0, );
    _util.semicolon.call(void 0, );
    return true;
  } else if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._as)) {
    // `export as namespace A;`
    // See `parseNamespaceExportDeclaration` in TypeScript's own parser
    _util.expectContextual.call(void 0, _keywords.ContextualKeyword._namespace);
    _expression.parseIdentifier.call(void 0, );
    _util.semicolon.call(void 0, );
    return true;
  } else {
    if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._type) &amp;&amp; _index.lookaheadType.call(void 0, ) === _types.TokenType.braceL) {
      _index.next.call(void 0, );
    }
    return false;
  }
} exports.tsTryParseExport = tsTryParseExport;

 function tsTryParseExportDefaultExpression() {
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._abstract) &amp;&amp; _index.lookaheadType.call(void 0, ) === _types.TokenType._class) {
    _base.state.type = _types.TokenType._abstract;
    _index.next.call(void 0, ); // Skip "abstract"
    _statement.parseClass.call(void 0, true, true);
    return true;
  }
  if (_util.isContextual.call(void 0, _keywords.ContextualKeyword._interface)) {
    // Make sure "export default" are considered type tokens so the whole thing is removed.
    const oldIsType = _index.pushTypeContext.call(void 0, 2);
    tsParseDeclaration(_keywords.ContextualKeyword._interface, true);
    _index.popTypeContext.call(void 0, oldIsType);
    return true;
  }
  return false;
} exports.tsTryParseExportDefaultExpression = tsTryParseExportDefaultExpression;

 function tsTryParseStatementContent() {
  if (_base.state.type === _types.TokenType._const) {
    const ahead = _index.lookaheadTypeAndKeyword.call(void 0, );
    if (ahead.type === _types.TokenType.name &amp;&amp; ahead.contextualKeyword === _keywords.ContextualKeyword._enum) {
      _util.expect.call(void 0, _types.TokenType._const);
      _util.expectContextual.call(void 0, _keywords.ContextualKeyword._enum);
      _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._enum;
      tsParseEnumDeclaration();
      return true;
    }
  }
  return false;
} exports.tsTryParseStatementContent = tsTryParseStatementContent;

 function tsParseAccessModifier() {
  tsParseModifier([
    _keywords.ContextualKeyword._public,
    _keywords.ContextualKeyword._protected,
    _keywords.ContextualKeyword._private,
  ]);
} exports.tsParseAccessModifier = tsParseAccessModifier;

 function tsTryParseClassMemberWithIsStatic(
  isStatic,
  classContextId,
) {
  let isAbstract = false;
  let isReadonly = false;

  while (true) {
    const mod = tsParseModifier([
      _keywords.ContextualKeyword._abstract,
      _keywords.ContextualKeyword._readonly,
      _keywords.ContextualKeyword._declare,
    ]);
    if (mod == null) {
      break;
    }
    if (mod === _keywords.ContextualKeyword._readonly) {
      isReadonly = true;
    }
    if (mod === _keywords.ContextualKeyword._abstract) {
      isAbstract = true;
    }
  }

  // We no longer check for public/private/etc, but tsTryParseIndexSignature should just return
  // false in that case for valid code.
  if (!isAbstract &amp;&amp; !isStatic) {
    const found = tsTryParseIndexSignature();
    if (found) {
      return true;
    }
  }

  if (isReadonly) {
    // Must be a property (if not an index signature).
    _statement.parseClassPropertyName.call(void 0, classContextId);
    _statement.parsePostMemberNameModifiers.call(void 0, );
    _statement.parseClassProperty.call(void 0, );
    return true;
  }
  return false;
} exports.tsTryParseClassMemberWithIsStatic = tsTryParseClassMemberWithIsStatic;

// Note: The reason we do this in `parseIdentifierStatement` and not `parseStatement`
// is that e.g. `type()` is valid JS, so we must try parsing that first.
// If it's really a type, we will parse `type` as the statement, and can correct it here
// by parsing the rest.
 function tsParseIdentifierStatement(contextualKeyword) {
  const matched = tsParseExpressionStatement(contextualKeyword);
  if (!matched) {
    _util.semicolon.call(void 0, );
  }
} exports.tsParseIdentifierStatement = tsParseIdentifierStatement;

 function tsParseExportDeclaration() {
  // "export declare" is equivalent to just "export".
  const isDeclare = _util.eatContextual.call(void 0, _keywords.ContextualKeyword._declare);
  if (isDeclare) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._declare;
  }

  let matchedDeclaration = false;
  if (_index.match.call(void 0, _types.TokenType.name)) {
    if (isDeclare) {
      const oldIsType = _index.pushTypeContext.call(void 0, 2);
      matchedDeclaration = tsTryParseExportDeclaration();
      _index.popTypeContext.call(void 0, oldIsType);
    } else {
      matchedDeclaration = tsTryParseExportDeclaration();
    }
  }
  if (!matchedDeclaration) {
    if (isDeclare) {
      const oldIsType = _index.pushTypeContext.call(void 0, 2);
      _statement.parseStatement.call(void 0, true);
      _index.popTypeContext.call(void 0, oldIsType);
    } else {
      _statement.parseStatement.call(void 0, true);
    }
  }
} exports.tsParseExportDeclaration = tsParseExportDeclaration;

 function tsAfterParseClassSuper(hasSuper) {
  if (hasSuper &amp;&amp; _index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
  if (_util.eatContextual.call(void 0, _keywords.ContextualKeyword._implements)) {
    _base.state.tokens[_base.state.tokens.length - 1].type = _types.TokenType._implements;
    const oldIsType = _index.pushTypeContext.call(void 0, 1);
    tsParseHeritageClause();
    _index.popTypeContext.call(void 0, oldIsType);
  }
} exports.tsAfterParseClassSuper = tsAfterParseClassSuper;

 function tsStartParseObjPropValue() {
  tsTryParseTypeParameters();
} exports.tsStartParseObjPropValue = tsStartParseObjPropValue;

 function tsStartParseFunctionParams() {
  tsTryParseTypeParameters();
} exports.tsStartParseFunctionParams = tsStartParseFunctionParams;

// `let x: number;`
 function tsAfterParseVarHead() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _index.eat.call(void 0, _types.TokenType.bang);
  tsTryParseTypeAnnotation();
  _index.popTypeContext.call(void 0, oldIsType);
} exports.tsAfterParseVarHead = tsAfterParseVarHead;

// parse the return type of an async arrow function - let foo = (async (): number => {});
 function tsStartParseAsyncArrowFromCallExpression() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    tsParseTypeAnnotation();
  }
} exports.tsStartParseAsyncArrowFromCallExpression = tsStartParseAsyncArrowFromCallExpression;

// Returns true if the expression was an arrow function.
 function tsParseMaybeAssign(noIn, isWithinParens) {
  // Note: When the JSX plugin is on, type assertions (`&lt;T> x`) aren't valid syntax.
  if (_base.isJSXEnabled) {
    return tsParseMaybeAssignWithJSX(noIn, isWithinParens);
  } else {
    return tsParseMaybeAssignWithoutJSX(noIn, isWithinParens);
  }
} exports.tsParseMaybeAssign = tsParseMaybeAssign;

 function tsParseMaybeAssignWithJSX(noIn, isWithinParens) {
  if (!_index.match.call(void 0, _types.TokenType.lessThan)) {
    return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  }

  // Prefer to parse JSX if possible. But may be an arrow fn.
  const snapshot = _base.state.snapshot();
  let wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }

  // Otherwise, try as type-parameterized arrow function.
  _base.state.type = _types.TokenType.typeParameterStart;
  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
  tsParseTypeParameters();
  wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  if (!wasArrow) {
    _util.unexpected.call(void 0, );
  }

  return wasArrow;
} exports.tsParseMaybeAssignWithJSX = tsParseMaybeAssignWithJSX;

 function tsParseMaybeAssignWithoutJSX(noIn, isWithinParens) {
  if (!_index.match.call(void 0, _types.TokenType.lessThan)) {
    return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  }

  const snapshot = _base.state.snapshot();
  // This is similar to TypeScript's `tryParseParenthesizedArrowFunctionExpression`.
  tsParseTypeParameters();
  const wasArrow = _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
  if (!wasArrow) {
    _util.unexpected.call(void 0, );
  }
  if (_base.state.error) {
    _base.state.restoreFromSnapshot(snapshot);
  } else {
    return wasArrow;
  }

  // Try parsing a type cast instead of an arrow function.
  // This will start with a type assertion (via parseMaybeUnary).
  // But don't directly call `tsParseTypeAssertion` because we want to handle any binary after it.
  return _expression.baseParseMaybeAssign.call(void 0, noIn, isWithinParens);
} exports.tsParseMaybeAssignWithoutJSX = tsParseMaybeAssignWithoutJSX;

 function tsParseArrow() {
  if (_index.match.call(void 0, _types.TokenType.colon)) {
    // This is different from how the TS parser does it.
    // TS uses lookahead. Babylon parses it as a parenthesized expression and converts.
    const snapshot = _base.state.snapshot();

    tsParseTypeOrTypePredicateAnnotation(_types.TokenType.colon);
    if (_util.canInsertSemicolon.call(void 0, )) _util.unexpected.call(void 0, );
    if (!_index.match.call(void 0, _types.TokenType.arrow)) _util.unexpected.call(void 0, );

    if (_base.state.error) {
      _base.state.restoreFromSnapshot(snapshot);
    }
  }
  return _index.eat.call(void 0, _types.TokenType.arrow);
} exports.tsParseArrow = tsParseArrow;

// Allow type annotations inside of a parameter list.
 function tsParseAssignableListItemTypes() {
  const oldIsType = _index.pushTypeContext.call(void 0, 0);
  _index.eat.call(void 0, _types.TokenType.question);
  tsTryParseTypeAnnotation();
  _index.popTypeContext.call(void 0, oldIsType);
} exports.tsParseAssignableListItemTypes = tsParseAssignableListItemTypes;

 function tsParseMaybeDecoratorArguments() {
  if (_index.match.call(void 0, _types.TokenType.lessThan)) {
    tsParseTypeArguments();
  }
  _statement.baseParseMaybeDecoratorArguments.call(void 0, );
} exports.tsParseMaybeDecoratorArguments = tsParseMaybeDecoratorArguments;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ColorConverter.html">ColorConverter</a></li><li><a href="module-ContextMenu.html">ContextMenu</a></li><li><a href="module-DiscordAPI.html">DiscordAPI</a></li><li><a href="module-DiscordClasses.html">DiscordClasses</a></li><li><a href="module-DiscordClassModules.html">DiscordClassModules</a></li><li><a href="module-DiscordContextMenu.html">DiscordContextMenu</a></li><li><a href="module-DiscordModules.html">DiscordModules</a></li><li><a href="module-DiscordSelectors.html">DiscordSelectors</a></li><li><a href="module-DOMTools.html">DOMTools</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-Modals.html">Modals</a></li><li><a href="module-Patcher.html">Patcher</a></li><li><a href="module-PluginUpdater.html">PluginUpdater</a></li><li><a href="module-PluginUtilities.html">PluginUtilities</a></li><li><a href="module-Popouts.html">Popouts</a></li><li><a href="module-powercord_injector.html">powercord/injector</a></li><li><a href="module-ReactComponents.html">ReactComponents</a></li><li><a href="module-ReactTools.html">ReactTools</a></li><li><a href="module-Settings.html">Settings</a></li><li><a href="module-Toasts.html">Toasts</a></li><li><a href="module-Tooltip.html">Tooltip</a></li><li><a href="module-Utilities.html">Utilities</a></li><li><a href="module-WebpackModules.html">WebpackModules</a></li></ul><h3>Classes</h3><ul><li><a href="global.html#ArraySet">ArraySet</a></li><li><a href="global.html#BasicSourceMapConsumer">BasicSourceMapConsumer</a></li><li><a href="CJSImportProcessor.html">CJSImportProcessor</a></li><li><a href="CJSImportTransformer.html">CJSImportTransformer</a></li><li><a href="CommanderError.html">CommanderError</a></li><li><a href="CommandsAPI.html">CommandsAPI</a></li><li><a href="global.html#Compiler">Compiler</a></li><li><a href="CompressedObject.html">CompressedObject</a></li><li><a href="ConvertWorker.html">ConvertWorker</a></li><li><a href="Crc32Probe.html">Crc32Probe</a></li><li><a href="CSS.html">CSS</a></li><li><a href="DataLengthProbe.html">DataLengthProbe</a></li><li><a href="DataWorker.html">DataWorker</a></li><li><a href="DirEntry.html">DirEntry</a></li><li><a href="ESMImportTransformer.html">ESMImportTransformer</a></li><li><a href="FlateWorker.html">FlateWorker</a></li><li><a href="FSWatcher.html">FSWatcher</a></li><li><a href="GenericWorker.html">GenericWorker</a></li><li><a href="global.html#IndexedSourceMapConsumer">IndexedSourceMapConsumer</a></li><li><a href="JSX.html">JSX</a></li><li><a href="JSZip.html">JSZip</a></li><li><a href="KeybindsAPI.html">KeybindsAPI</a></li><li><a href="LabsAPI.html">LabsAPI</a></li><li><a href="Less.html">Less</a></li><li><a href="LessError.html">LessError</a></li><li><a href="global.html#MappingList">MappingList</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module-ContextMenu-ImageItem.html">ImageItem</a></li><li><a href="module-ContextMenu-ItemGroup.html">ItemGroup</a></li><li><a href="module-ContextMenu-Menu.html">Menu</a></li><li><a href="module-ContextMenu-MenuItem.html">MenuItem</a></li><li><a href="module-ContextMenu-SubMenuItem.html">SubMenuItem</a></li><li><a href="module-ContextMenu-TextItem.html">TextItem</a></li><li><a href="module-ContextMenu-ToggleItem.html">ToggleItem</a></li><li><a href="module-DiscordAPI.Channel.html">Channel</a></li><li><a href="module-DiscordAPI.Guild.html">Guild</a></li><li><a href="module-DiscordAPI.InsufficientPermissions.html">InsufficientPermissions</a></li><li><a href="module-DiscordAPI.Message.html">Message</a></li><li><a href="module-DiscordAPI.User.html">User</a></li><li><a href="module-DiscordAPI.UserSettings.html">UserSettings</a></li><li><a href="module-DOMTools.ClassName.html">ClassName</a></li><li><a href="module-DOMTools.DOMObserver.html">DOMObserver</a></li><li><a href="module-DOMTools.Selector.html">Selector</a></li><li><a href="module-PluginUtilities-Helpers.html">Helpers</a></li><li><a href="module-ReactTools-Reflection.html">Reflection</a></li><li><a href="module-Settings.ColorPicker.html">ColorPicker</a></li><li><a href="module-Settings.Dropdown.html">Dropdown</a></li><li><a href="module-Settings.FilePicker.html">FilePicker</a></li><li><a href="module-Settings.Keybind.html">Keybind</a></li><li><a href="module-Settings.RadioGroup.html">RadioGroup</a></li><li><a href="module-Settings.SettingField.html">SettingField</a></li><li><a href="module-Settings.SettingGroup.html">SettingGroup</a></li><li><a href="module-Settings.SettingPanel.html">SettingPanel</a></li><li><a href="module-Settings.Slider.html">Slider</a></li><li><a href="module-Settings.Switch.html">Switch</a></li><li><a href="module-Settings.Textbox.html">Textbox</a></li><li><a href="module-Tooltip-Tooltip.html">Tooltip</a></li><li><a href="module-WebpackModules-Filters.html">Filters</a></li><li><a href="module-WebpackModules-List.html">List</a></li><li><a href="module-WebpackModules-Listenable.html">Listenable</a></li><li><a href="module-WebpackModules-Screen.html">Screen</a></li><li><a href="NodejsStreamInputAdapter.html">NodejsStreamInputAdapter</a></li><li><a href="NodejsStreamOutputAdapter.html">NodejsStreamOutputAdapter</a></li><li><a href="OptionalChainingNullishTransformer.html">OptionalChainingNullishTransformer</a></li><li><a href="Plugin.html">Plugin</a></li><li><a href="Powercord.html">Powercord</a></li><li><a href="ReactDisplayNameTransformer.html">ReactDisplayNameTransformer</a></li><li><a href="RouterAPI.html">RouterAPI</a></li><li><a href="RpcAPI.html">RpcAPI</a></li><li><a href="SCSS.html">SCSS</a></li><li><a href="Section.html">Section</a></li><li><a href="SettingsAPI.html">SettingsAPI</a></li><li><a href="global.html#SourceMapGenerator">SourceMapGenerator</a></li><li><a href="global.html#SourceNode">SourceNode</a></li><li><a href="StreamHelper.html">StreamHelper</a></li><li><a href="Stylus.html">Stylus</a></li><li><a href="Updatable.html">Updatable</a></li><li><a href="Utf8DecodeWorker.html">Utf8DecodeWorker</a></li><li><a href="Utf8EncodeWorker.html">Utf8EncodeWorker</a></li><li><a href="ZipEntries.html">ZipEntries</a></li><li><a href="ZipEntry.html">ZipEntry</a></li><li><a href="ZipObject.html">ZipObject</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-DiscordContextMenu-MenuControlItem.html">MenuControlItem</a></li><li><a href="module-DiscordContextMenu-MenuItem.html">MenuItem</a></li><li><a href="module-DiscordContextMenu-MenuRadioItem.html">MenuRadioItem</a></li><li><a href="module-DiscordContextMenu-MenuToggleItem.html">MenuToggleItem</a></li><li><a href="module-DiscordContextMenu-SubMenuItem.html">SubMenuItem</a></li><li><a href="module-DOMTools-Offset.html">Offset</a></li><li><a href="module-FilePicker.html">FilePicker</a></li><li><a href="module-Modals-Changelog.html">Changelog</a></li><li><a href="module-Settings-DropdownItem.html">DropdownItem</a></li><li><a href="module-Settings-RadioItem.html">RadioItem</a></li></ul><h3>Mixins</h3><ul><li><a href="FsEventsHandler.html">FsEventsHandler</a></li><li><a href="NodeFsHandler.html">NodeFsHandler</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#__extends">__extends</a></li><li><a href="global.html#__importDefault">__importDefault</a></li><li><a href="global.html#_init">_init</a></li><li><a href="global.html#_tsinterfacechecker">_tsinterfacechecker</a></li><li><a href="global.html#_utf8len">_utf8len</a></li><li><a href="global.html#absolute">absolute</a></li><li><a href="global.html#accumulate">accumulate</a></li><li><a href="global.html#addFile">addFile</a></li><li><a href="global.html#addHook">addHook</a></li><li><a href="global.html#addParent">addParent</a></li><li><a href="global.html#adjust">adjust</a></li><li><a href="global.html#alias">alias</a></li><li><a href="global.html#alpha">alpha</a></li><li><a href="global.html#AnsiEscapes">AnsiEscapes</a></li><li><a href="global.html#anymatch">anymatch</a></li><li><a href="global.html#applySourceMaps">applySourceMaps</a></li><li><a href="global.html#Arguments">Arguments</a></li><li><a href="global.html#array">array</a></li><li><a href="global.html#arrayLikeToArrayLike">arrayLikeToArrayLike</a></li><li><a href="global.html#arrayLikeToString">arrayLikeToString</a></li><li><a href="global.html#arrayToStringHelper">arrayToStringHelper</a></li><li><a href="global.html#assertColor">assertColor</a></li><li><a href="global.html#assertPresent">assertPresent</a></li><li><a href="global.html#assertString">assertString</a></li><li><a href="global.html#assertType">assertType</a></li><li><a href="global.html#Atblock">Atblock</a></li><li><a href="global.html#Atrule">Atrule</a></li><li><a href="global.html#Base">Base</a></li><li><a href="global.html#basename">basename</a></li><li><a href="global.html#baseParseSubscript">baseParseSubscript</a></li><li><a href="global.html#BasicType">BasicType</a></li><li><a href="global.html#basicTypes">basicTypes</a></li><li><a href="global.html#BinOp">BinOp</a></li><li><a href="global.html#blend">blend</a></li><li><a href="global.html#Block">Block</a></li><li><a href="global.html#blue">blue</a></li><li><a href="global.html#Boolean">Boolean</a></li><li><a href="global.html#braces">braces</a></li><li><a href="global.html#Call">Call</a></li><li><a href="global.html#camelcase">camelcase</a></li><li><a href="global.html#catch">catch</a></li><li><a href="global.html#charset">charset</a></li><li><a href="global.html#Charset">Charset</a></li><li><a href="global.html#checkEntryCRC32">checkEntryCRC32</a></li><li><a href="global.html#Checker">Checker</a></li><li><a href="global.html#checkImports">checkImports</a></li><li><a href="global.html#checkSupport">checkSupport</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clampAlpha">clampAlpha</a></li><li><a href="global.html#clampDegrees">clampDegrees</a></li><li><a href="global.html#clampPercentage">clampPercentage</a></li><li><a href="global.html#coerce">coerce</a></li><li><a href="global.html#coerceArray">coerceArray</a></li><li><a href="global.html#coerceObject">coerceObject</a></li><li><a href="global.html#CoercionError">CoercionError</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#Command">Command</a></li><li><a href="global.html#comment">comment</a></li><li><a href="global.html#Comment">Comment</a></li><li><a href="global.html#compare">compare</a></li><li><a href="global.html#compareByGeneratedPositionsDeflated">compareByGeneratedPositionsDeflated</a></li><li><a href="global.html#compareByGeneratedPositionsInflated">compareByGeneratedPositionsInflated</a></li><li><a href="global.html#compareByOriginalPositions">compareByOriginalPositions</a></li><li><a href="global.html#compile">compile</a></li><li><a href="global.html#compileSelectors">compileSelectors</a></li><li><a href="global.html#component">component</a></li><li><a href="global.html#componentMap">componentMap</a></li><li><a href="global.html#Compressed">Compressed</a></li><li><a href="global.html#computeSourceMap">computeSourceMap</a></li><li><a href="global.html#computeSourceURL">computeSourceURL</a></li><li><a href="global.html#concat">concat</a></li><li><a href="global.html#config">config</a></li><li><a href="global.html#contentType">contentType</a></li><li><a href="global.html#contrast">contrast</a></li><li><a href="global.html#convert">convert</a></li><li><a href="global.html#convertCSS">convertCSS</a></li><li><a href="global.html#Converter">Converter</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#coremods">coremods</a></li><li><a href="global.html#crc32str">crc32str</a></li><li><a href="global.html#createCheckers">createCheckers</a></li><li><a href="global.html#createDebug">createDebug</a></li><li><a href="global.html#createFSEventsInstance">createFSEventsInstance</a></li><li><a href="global.html#createFsWatchInstance">createFsWatchInstance</a></li><li><a href="global.html#createPattern">createPattern</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#defaultMimes">defaultMimes</a></li><li><a href="global.html#define">define</a></li><li><a href="global.html#deflate">deflate</a></li><li><a href="global.html#Deflate">Deflate</a></li><li><a href="global.html#deflateRaw">deflateRaw</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#deprecate">deprecate</a></li><li><a href="global.html#DepsResolver">DepsResolver</a></li><li><a href="global.html#DetailContext">DetailContext</a></li><li><a href="global.html#dirname">dirname</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#disableAll">disableAll</a></li><li><a href="global.html#doQuickSort">doQuickSort</a></li><li><a href="global.html#DOT_LITERAL">DOT_LITERAL</a></li><li><a href="global.html#Each">Each</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#enableAll">enableAll</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#encloseBrace">encloseBrace</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodingTypes">encodingTypes</a></li><li><a href="global.html#enumlit">enumlit</a></li><li><a href="global.html#enumtype">enumtype</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#escapeNode">escapeNode</a></li><li><a href="global.html#Evaluator">Evaluator</a></li><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#events">events</a></li><li><a href="global.html#exceedsLimit">exceedsLimit</a></li><li><a href="global.html#expandRange">expandRange</a></li><li><a href="global.html#Expression">Expression</a></li><li><a href="global.html#Extend">Extend</a></li><li><a href="global.html#extension">extension</a></li><li><a href="global.html#extname">extname</a></li><li><a href="global.html#FACTOR_TABLE">FACTOR_TABLE</a></li><li><a href="global.html#Feature">Feature</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findCompression">findCompression</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#formatException">formatException</a></li><li><a href="global.html#formatJSXStringValueLiteral">formatJSXStringValueLiteral</a></li><li><a href="global.html#formatJSXTextLiteral">formatJSXTextLiteral</a></li><li><a href="global.html#formatJSXTextReplacement">formatJSXTextReplacement</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#Frame">Frame</a></li><li><a href="global.html#fromHSLA">fromHSLA</a></li><li><a href="global.html#fromRGBA">fromRGBA</a></li><li><a href="global.html#fromVLQSigned">fromVLQSigned</a></li><li><a href="global.html#fs">fs</a></li><li><a href="global.html#FSEventsWatchers">FSEventsWatchers</a></li><li><a href="global.html#fsWatchBroadcast">fsWatchBroadcast</a></li><li><a href="global.html#FsWatchInstances">FsWatchInstances</a></li><li><a href="global.html#func">func</a></li><li><a href="global.html#Function">Function</a></li><li><a href="global.html#functions">functions</a></li><li><a href="global.html#generateCentralDirectoryEnd">generateCentralDirectoryEnd</a></li><li><a href="global.html#generateDataDescriptors">generateDataDescriptors</a></li><li><a href="global.html#generateDosExternalFileAttr">generateDosExternalFileAttr</a></li><li><a href="global.html#generatedPositionAfter">generatedPositionAfter</a></li><li><a href="global.html#generateUnixExternalFileAttr">generateUnixExternalFileAttr</a></li><li><a href="global.html#generateWorker">generateWorker</a></li><li><a href="global.html#generateZipParts">generateZipParts</a></li><li><a href="global.html#genIterator">genIterator</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAppDir">getAppDir</a></li><li><a href="global.html#getArg">getArg</a></li><li><a href="global.html#getCache">getCache</a></li><li><a href="global.html#getClassInfo">getClassInfo</a></li><li><a href="global.html#getCompression">getCompression</a></li><li><a href="global.html#getDeclarationInfo">getDeclarationInfo</a></li><li><a href="global.html#getFormattedTokens">getFormattedTokens</a></li><li><a href="global.html#getIdentifierNames">getIdentifierNames</a></li><li><a href="global.html#getSucraseContext">getSucraseContext</a></li><li><a href="global.html#getTSImportedNames">getTSImportedNames</a></li><li><a href="global.html#getType">getType</a></li><li><a href="global.html#getTypeOf">getTypeOf</a></li><li><a href="global.html#green">green</a></li><li><a href="global.html#Group">Group</a></li><li><a href="global.html#gzip">gzip</a></li><li><a href="global.html#hasOwnProperty">hasOwnProperty</a></li><li><a href="global.html#hasShadowedGlobals">hasShadowedGlobals</a></li><li><a href="global.html#hsl">hsl</a></li><li><a href="global.html#hsla">hsla</a></li><li><a href="global.html#HSLA">HSLA</a></li><li><a href="global.html#hue">hue</a></li><li><a href="global.html#humanReadableArgName">humanReadableArgName</a></li><li><a href="global.html#Ident">Ident</a></li><li><a href="global.html#identifyShadowedGlobals">identifyShadowedGlobals</a></li><li><a href="global.html#identity">identity</a></li><li><a href="global.html#If">If</a></li><li><a href="global.html#iface">iface</a></li><li><a href="global.html#Image">Image</a></li><li><a href="global.html#imageSize">imageSize</a></li><li><a href="global.html#Import">Import</a></li><li><a href="global.html#importFile">importFile</a></li><li><a href="global.html#imports">imports</a></li><li><a href="global.html#incrementNodeInspectorPort">incrementNodeInspectorPort</a></li><li><a href="global.html#Inflate">Inflate</a></li><li><a href="global.html#inflate">inflate</a></li><li><a href="global.html#inflateRaw">inflateRaw</a></li><li><a href="global.html#inherits">inherits</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#inspect">inspect</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#instances">instances</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#isAccessModifier">isAccessModifier</a></li><li><a href="global.html#isAnyObject">isAnyObject</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isAsyncOperation">isAsyncOperation</a></li><li><a href="global.html#isBlob">isBlob</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isDate">isDate</a></li><li><a href="global.html#isEmptyArray">isEmptyArray</a></li><li><a href="global.html#isEmptyObject">isEmptyObject</a></li><li><a href="global.html#isEmptyString">isEmptyString</a></li><li><a href="global.html#isError">isError</a></li><li><a href="global.html#isFile">isFile</a></li><li><a href="global.html#isFullArray">isFullArray</a></li><li><a href="global.html#isFullObject">isFullObject</a></li><li><a href="global.html#isFullString">isFullString</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isInvalidBrace">isInvalidBrace</a></li><li><a href="global.html#isMap">isMap</a></li><li><a href="global.html#isNaNValue">isNaNValue</a></li><li><a href="global.html#isNull">isNull</a></li><li><a href="global.html#isNullOrUndefined">isNullOrUndefined</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isObjectLike">isObjectLike</a></li><li><a href="global.html#isOpenOrClose">isOpenOrClose</a></li><li><a href="global.html#isPlainObject">isPlainObject</a></li><li><a href="global.html#isPrimitive">isPrimitive</a></li><li><a href="global.html#isPromise">isPromise</a></li><li><a href="global.html#isRegExp">isRegExp</a></li><li><a href="global.html#isRegistered">isRegistered</a></li><li><a href="global.html#isSet">isSet</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#isSymbol">isSymbol</a></li><li><a href="global.html#isType">isType</a></li><li><a href="global.html#isUndefined">isUndefined</a></li><li><a href="global.html#isWeakMap">isWeakMap</a></li><li><a href="global.html#isWeakSet">isWeakSet</a></li><li><a href="global.html#join">join</a></li><li><a href="global.html#json">json</a></li><li><a href="global.html#jsonCharacterEncoding">jsonCharacterEncoding</a></li><li><a href="global.html#jsonMimeTypeRegex">jsonMimeTypeRegex</a></li><li><a href="global.html#Keyframes">Keyframes</a></li><li><a href="global.html#lessFolder">lessFolder</a></li><li><a href="global.html#Lexer">Lexer</a></li><li><a href="global.html#lightness">lightness</a></li><li><a href="global.html#lit">lit</a></li><li><a href="global.html#Literal">Literal</a></li><li><a href="global.html#literal">literal</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadImplementation">loadImplementation</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#lookup">lookup</a></li><li><a href="global.html#lookupIndex">lookupIndex</a></li><li><a href="global.html#lruMemoize">lruMemoize</a></li><li><a href="global.html#luminosity">luminosity</a></li><li><a href="global.html#makeTable">makeTable</a></li><li><a href="global.html#Mapping">Mapping</a></li><li><a href="global.html#match">match</a></li><li><a href="global.html#matchPatterns">matchPatterns</a></li><li><a href="global.html#math">math</a></li><li><a href="global.html#Media">Media</a></li><li><a href="global.html#Member">Member</a></li><li><a href="global.html#merge">merge</a></li><li><a href="global.html#middleware">middleware</a></li><li><a href="global.html#mime">mime</a></li><li><a href="global.html#mixin">mixin</a></li><li><a href="global.html#Module">Module</a></li><li><a href="global.html#modules">modules</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#names">names</a></li><li><a href="global.html#Namespace">Namespace</a></li><li><a href="global.html#newBlob">newBlob</a></li><li><a href="global.html#next">next</a></li><li><a href="global.html#Node">Node</a></li><li><a href="global.html#nodes">nodes</a></li><li><a href="global.html#NoopContext">NoopContext</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#Normalizer">Normalizer</a></li><li><a href="global.html#Null">Null</a></li><li><a href="global.html#NullCache">NullCache</a></li><li><a href="global.html#Object">Object</a></li><li><a href="global.html#Observable">Observable</a></li><li><a href="global.html#oldJson">oldJson</a></li><li><a href="global.html#operate">operate</a></li><li><a href="global.html#opt">opt</a></li><li><a href="global.html#Option">Option</a></li><li><a href="global.html#optionalWrap">optionalWrap</a></li><li><a href="global.html#outputHelpIfRequested">outputHelpIfRequested</a></li><li><a href="global.html#pad">pad</a></li><li><a href="global.html#param">param</a></li><li><a href="global.html#Params">Params</a></li><li><a href="global.html#params">params</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#ParseError">ParseError</a></li><li><a href="global.html#parseIdentifierStatement">parseIdentifierStatement</a></li><li><a href="global.html#parseMaybeAssign">parseMaybeAssign</a></li><li><a href="global.html#parseObject">parseObject</a></li><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#parseSourceMapInput">parseSourceMapInput</a></li><li><a href="global.html#parseSpec">parseSpec</a></li><li><a href="global.html#parseString">parseString</a></li><li><a href="global.html#picomatch">picomatch</a></li><li><a href="global.html#PluginLoader">PluginLoader</a></li><li><a href="global.html#PluginManager">PluginManager</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#POSIX_REGEX_SOURCE">POSIX_REGEX_SOURCE</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#prefixClasses">prefixClasses</a></li><li><a href="global.html#prepareContent">prepareContent</a></li><li><a href="global.html#pretty">pretty</a></li><li><a href="global.html#processConstructor">processConstructor</a></li><li><a href="global.html#processEntity">processEntity</a></li><li><a href="global.html#Property">Property</a></li><li><a href="global.html#pseudoSelectors">pseudoSelectors</a></li><li><a href="global.html#publisher">publisher</a></li><li><a href="global.html#Query">Query</a></li><li><a href="global.html#QueryList">QueryList</a></li><li><a href="global.html#querystring">querystring</a></li><li><a href="global.html#quickSort">quickSort</a></li><li><a href="global.html#randomIntInRange">randomIntInRange</a></li><li><a href="global.html#range">range</a></li><li><a href="global.html#rangeToPattern">rangeToPattern</a></li><li><a href="global.html#raw">raw</a></li><li><a href="global.html#readdirp">readdirp</a></li><li><a href="global.html#readWord">readWord</a></li><li><a href="global.html#recursiveSearch">recursiveSearch</a></li><li><a href="global.html#red">red</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#relative">relative</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#Renderer">Renderer</a></li><li><a href="global.html#replace">replace</a></li><li><a href="global.html#request">request</a></li><li><a href="global.html#Return">Return</a></li><li><a href="global.html#rgb">rgb</a></li><li><a href="global.html#RGBA">RGBA</a></li><li><a href="global.html#rgba">rgba</a></li><li><a href="global.html#rmdirRf">rmdirRf</a></li><li><a href="global.html#Root">Root</a></li><li><a href="global.html#runSerial">runSerial</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#saturation">saturation</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#scan">scan</a></li><li><a href="global.html#Scope">Scope</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#selectColor">selectColor</a></li><li><a href="global.html#Selector">Selector</a></li><li><a href="global.html#selectorExists">selectorExists</a></li><li><a href="global.html#SelectorParser">SelectorParser</a></li><li><a href="global.html#selectorTokens">selectorTokens</a></li><li><a href="global.html#setFSEventsListener">setFSEventsListener</a></li><li><a href="global.html#setFsWatchFileListener">setFsWatchFileListener</a></li><li><a href="global.html#setFsWatchListener">setFsWatchListener</a></li><li><a href="global.html#shouldElideDefaultExport">shouldElideDefaultExport</a></li><li><a href="global.html#shouldPreferGlobalPromise">shouldPreferGlobalPromise</a></li><li><a href="global.html#skipFieldName">skipFieldName</a></li><li><a href="global.html#skipToNextClassElement">skipToNextClassElement</a></li><li><a href="global.html#SourceMap">SourceMap</a></li><li><a href="global.html#SourceMapper">SourceMapper</a></li><li><a href="global.html#split">split</a></li><li><a href="global.html#Stack">Stack</a></li><li><a href="global.html#startsWithLowerCase">startsWithLowerCase</a></li><li><a href="global.html#String">String</a></li><li><a href="global.html#string2binary">string2binary</a></li><li><a href="global.html#stringToArrayLike">stringToArrayLike</a></li><li><a href="global.html#stylus">stylus</a></li><li><a href="global.html#subscribe">subscribe</a></li><li><a href="global.html#subscribers">subscribers</a></li><li><a href="global.html#substr">substr</a></li><li><a href="global.html#Supports">Supports</a></li><li><a href="global.html#swap">swap</a></li><li><a href="global.html#SyntaxError">SyntaxError</a></li><li><a href="global.html#syntaxError">syntaxError</a></li><li><a href="global.html#tan">tan</a></li><li><a href="global.html#Ternary">Ternary</a></li><li><a href="global.html#tests">tests</a></li><li><a href="global.html#then">then</a></li><li><a href="global.html#thenify">thenify</a></li><li><a href="global.html#thenifyAll">thenifyAll</a></li><li><a href="global.html#Token">Token</a></li><li><a href="global.html#TokenType">TokenType</a></li><li><a href="global.html#toSetString">toSetString</a></li><li><a href="global.html#toVLQSigned">toVLQSigned</a></li><li><a href="global.html#TParamList">TParamList</a></li><li><a href="global.html#TProp">TProp</a></li><li><a href="global.html#transformTo">transformTo</a></li><li><a href="global.html#transformZipOutput">transformZipOutput</a></li><li><a href="global.html#transparentify">transparentify</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#true">true</a></li><li><a href="global.html#tryAutoDetect">tryAutoDetect</a></li><li><a href="global.html#tsParseModifier">tsParseModifier</a></li><li><a href="global.html#tsParseTypePredicateOrAssertsPrefix">tsParseTypePredicateOrAssertsPrefix</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#TType">TType</a></li><li><a href="global.html#tuple">tuple</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#typedParseConditional">typedParseConditional</a></li><li><a href="global.html#typeMap">typeMap</a></li><li><a href="global.html#types_2">types_2</a></li><li><a href="global.html#UnaryOp">UnaryOp</a></li><li><a href="global.html#unexpected">unexpected</a></li><li><a href="global.html#union">union</a></li><li><a href="global.html#uniq">uniq</a></li><li><a href="global.html#unit">unit</a></li><li><a href="global.html#Unit">Unit</a></li><li><a href="global.html#unitMap">unitMap</a></li><li><a href="global.html#unquote">unquote</a></li><li><a href="global.html#unregister">unregister</a></li><li><a href="global.html#unregisterAll">unregisterAll</a></li><li><a href="global.html#unsubscribe">unsubscribe</a></li><li><a href="global.html#unwrap">unwrap</a></li><li><a href="global.html#updatePosition">updatePosition</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#use">use</a></li><li><a href="global.html#useColors">useColors</a></li><li><a href="global.html#utf8decode">utf8decode</a></li><li><a href="global.html#utf8encode">utf8encode</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VError">VError</a></li><li><a href="global.html#version">version</a></li><li><a href="global.html#visit">visit</a></li><li><a href="global.html#Visitor">Visitor</a></li><li><a href="global.html#warn">warn</a></li><li><a href="global.html#watch">watch</a></li><li><a href="global.html#webpack">webpack</a></li><li><a href="global.html#WINDOWS_CHARS">WINDOWS_CHARS</a></li><li><a href="global.html#withCallback">withCallback</a></li><li><a href="global.html#wrap">wrap</a></li><li><a href="global.html#ZeresPluginLibrary">ZeresPluginLibrary</a></li><li><a href="global.html#zip">zip</a></li><li><a href="global.html#ZipFileWorker">ZipFileWorker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Mon Mar 08 2021 15:13:56 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
