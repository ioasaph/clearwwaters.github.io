<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: node_modules/less/lib/less/parser/parser.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: node_modules/less/lib/less/parser/parser.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
var __createBinding = (this &amp;&amp; this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this &amp;&amp; this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this &amp;&amp; this.__importStar) || function (mod) {
    if (mod &amp;&amp; mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" &amp;&amp; Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this &amp;&amp; this.__importDefault) || function (mod) {
    return (mod &amp;&amp; mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var less_error_1 = __importDefault(require("../less-error"));
var tree_1 = __importDefault(require("../tree"));
var visitors_1 = __importDefault(require("../visitors"));
var parser_input_1 = __importDefault(require("./parser-input"));
var utils = __importStar(require("../utils"));
var function_registry_1 = __importDefault(require("../functions/function-registry"));
//
// less.js - parser
//
//    A relatively straight-forward predictive parser.
//    There is no tokenization/lexing stage, the input is parsed
//    in one sweep.
//
//    To make the parser fast enough to run in the browser, several
//    optimization had to be made:
//
//    - Matching and slicing on a huge input is often cause of slowdowns.
//      The solution is to chunkify the input into smaller strings.
//      The chunks are stored in the `chunks` var,
//      `j` holds the current chunk index, and `currentPos` holds
//      the index of the current chunk in relation to `input`.
//      This gives us an almost 4x speed-up.
//
//    - In many cases, we don't need to match individual tokens;
//      for example, if a value doesn't hold any variables, operations
//      or dynamic references, the parser can effectively 'skip' it,
//      treating it as a literal.
//      An example would be '1px solid #000' - which evaluates to itself,
//      we don't need to know what the individual components are.
//      The drawback, of course is that you don't get the benefits of
//      syntax-checking on the CSS. This gives us a 50% speed-up in the parser,
//      and a smaller speed-up in the code-gen.
//
//
//    Token matching is done with the `$` function, which either takes
//    a terminal string or regexp, or a non-terminal function to call.
//    It also takes care of moving all the indices forwards.
//
var Parser = function Parser(context, imports, fileInfo) {
    var parsers;
    var parserInput = parser_input_1.default();
    function error(msg, type) {
        throw new less_error_1.default({
            index: parserInput.i,
            filename: fileInfo.filename,
            type: type || 'Syntax',
            message: msg
        }, imports);
    }
    function expect(arg, msg) {
        // some older browsers return typeof 'function' for RegExp
        var result = (arg instanceof Function) ? arg.call(parsers) : parserInput.$re(arg);
        if (result) {
            return result;
        }
        error(msg || (typeof arg === 'string'
            ? "expected '" + arg + "' got '" + parserInput.currentChar() + "'"
            : 'unexpected token'));
    }
    // Specialization of expect()
    function expectChar(arg, msg) {
        if (parserInput.$char(arg)) {
            return arg;
        }
        error(msg || "expected '" + arg + "' got '" + parserInput.currentChar() + "'");
    }
    function getDebugInfo(index) {
        var filename = fileInfo.filename;
        return {
            lineNumber: utils.getLocation(index, parserInput.getInput()).line + 1,
            fileName: filename
        };
    }
    /**
     *  Used after initial parsing to create nodes on the fly
     *
     *  @param {String} str          - string to parse
     *  @param {Array}  parseList    - array of parsers to run input through e.g. ["value", "important"]
     *  @param {Number} currentIndex - start number to begin indexing
     *  @param {Object} fileInfo     - fileInfo to attach to created nodes
     */
    function parseNode(str, parseList, currentIndex, fileInfo, callback) {
        var result;
        var returnNodes = [];
        var parser = parserInput;
        try {
            parser.start(str, false, function fail(msg, index) {
                callback({
                    message: msg,
                    index: index + currentIndex
                });
            });
            for (var x = 0, p = void 0, i = void 0; (p = parseList[x]); x++) {
                i = parser.i;
                result = parsers[p]();
                if (result) {
                    try {
                        result._index = i + currentIndex;
                        result._fileInfo = fileInfo;
                    }
                    catch (e) { }
                    returnNodes.push(result);
                }
                else {
                    returnNodes.push(null);
                }
            }
            var endInfo = parser.end();
            if (endInfo.isFinished) {
                callback(null, returnNodes);
            }
            else {
                callback(true, null);
            }
        }
        catch (e) {
            throw new less_error_1.default({
                index: e.index + currentIndex,
                message: e.message
            }, imports, fileInfo.filename);
        }
    }
    //
    // The Parser
    //
    return {
        parserInput: parserInput,
        imports: imports,
        fileInfo: fileInfo,
        parseNode: parseNode,
        //
        // Parse an input string into an abstract syntax tree,
        // @param str A string containing 'less' markup
        // @param callback call `callback` when done.
        // @param [additionalData] An optional map which can contains vars - a map (key, value) of variables to apply
        //
        parse: function (str, callback, additionalData) {
            var root;
            var error = null;
            var globalVars;
            var modifyVars;
            var ignored;
            var preText = '';
            globalVars = (additionalData &amp;&amp; additionalData.globalVars) ? Parser.serializeVars(additionalData.globalVars) + "\n" : '';
            modifyVars = (additionalData &amp;&amp; additionalData.modifyVars) ? "\n" + Parser.serializeVars(additionalData.modifyVars) : '';
            if (context.pluginManager) {
                var preProcessors = context.pluginManager.getPreProcessors();
                for (var i = 0; i &lt; preProcessors.length; i++) {
                    str = preProcessors[i].process(str, { context: context, imports: imports, fileInfo: fileInfo });
                }
            }
            if (globalVars || (additionalData &amp;&amp; additionalData.banner)) {
                preText = ((additionalData &amp;&amp; additionalData.banner) ? additionalData.banner : '') + globalVars;
                ignored = imports.contentsIgnoredChars;
                ignored[fileInfo.filename] = ignored[fileInfo.filename] || 0;
                ignored[fileInfo.filename] += preText.length;
            }
            str = str.replace(/\r\n?/g, '\n');
            // Remove potential UTF Byte Order Mark
            str = preText + str.replace(/^\uFEFF/, '') + modifyVars;
            imports.contents[fileInfo.filename] = str;
            // Start with the primary rule.
            // The whole syntax tree is held under a Ruleset node,
            // with the `root` property set to true, so no `{}` are
            // output. The callback is called when the input is parsed.
            try {
                parserInput.start(str, context.chunkInput, function fail(msg, index) {
                    throw new less_error_1.default({
                        index: index,
                        type: 'Parse',
                        message: msg,
                        filename: fileInfo.filename
                    }, imports);
                });
                tree_1.default.Node.prototype.parse = this;
                root = new tree_1.default.Ruleset(null, this.parsers.primary());
                tree_1.default.Node.prototype.rootNode = root;
                root.root = true;
                root.firstRoot = true;
                root.functionRegistry = function_registry_1.default.inherit();
            }
            catch (e) {
                return callback(new less_error_1.default(e, imports, fileInfo.filename));
            }
            // If `i` is smaller than the `input.length - 1`,
            // it means the parser wasn't able to parse the whole
            // string, so we've got a parsing error.
            //
            // We try to extract a \n delimited string,
            // showing the line where the parse error occurred.
            // We split it up into two parts (the part which parsed,
            // and the part which didn't), so we can color them differently.
            var endInfo = parserInput.end();
            if (!endInfo.isFinished) {
                var message = endInfo.furthestPossibleErrorMessage;
                if (!message) {
                    message = 'Unrecognised input';
                    if (endInfo.furthestChar === '}') {
                        message += '. Possibly missing opening \'{\'';
                    }
                    else if (endInfo.furthestChar === ')') {
                        message += '. Possibly missing opening \'(\'';
                    }
                    else if (endInfo.furthestReachedEnd) {
                        message += '. Possibly missing something';
                    }
                }
                error = new less_error_1.default({
                    type: 'Parse',
                    message: message,
                    index: endInfo.furthest,
                    filename: fileInfo.filename
                }, imports);
            }
            var finish = function (e) {
                e = error || e || imports.error;
                if (e) {
                    if (!(e instanceof less_error_1.default)) {
                        e = new less_error_1.default(e, imports, fileInfo.filename);
                    }
                    return callback(e);
                }
                else {
                    return callback(null, root);
                }
            };
            if (context.processImports !== false) {
                new visitors_1.default.ImportVisitor(imports, finish)
                    .run(root);
            }
            else {
                return finish();
            }
        },
        //
        // Here in, the parsing rules/functions
        //
        // The basic structure of the syntax tree generated is as follows:
        //
        //   Ruleset ->  Declaration -> Value -> Expression -> Entity
        //
        // Here's some Less code:
        //
        //    .class {
        //      color: #fff;
        //      border: 1px solid #000;
        //      width: @w + 4px;
        //      > .child {...}
        //    }
        //
        // And here's what the parse tree might look like:
        //
        //     Ruleset (Selector '.class', [
        //         Declaration ("color",  Value ([Expression [Color #fff]]))
        //         Declaration ("border", Value ([Expression [Dimension 1px][Keyword "solid"][Color #000]]))
        //         Declaration ("width",  Value ([Expression [Operation " + " [Variable "@w"][Dimension 4px]]]))
        //         Ruleset (Selector [Element '>', '.child'], [...])
        //     ])
        //
        //  In general, most rules will try to parse a token with the `$re()` function, and if the return
        //  value is truly, will return a new node, of the relevant type. Sometimes, we need to check
        //  first, before parsing, that's when we use `peek()`.
        //
        parsers: parsers = {
            //
            // The `primary` rule is the *entry* and *exit* point of the parser.
            // The rules here can appear at any level of the parse tree.
            //
            // The recursive nature of the grammar is an interplay between the `block`
            // rule, which represents `{ ... }`, the `ruleset` rule, and this `primary` rule,
            // as represented by this simplified grammar:
            //
            //     primary  →  (ruleset | declaration)+
            //     ruleset  →  selector+ block
            //     block    →  '{' primary '}'
            //
            // Only at one point is the primary rule not called from the
            // block rule: at the root level.
            //
            primary: function () {
                var mixin = this.mixin;
                var root = [];
                var node;
                while (true) {
                    while (true) {
                        node = this.comment();
                        if (!node) {
                            break;
                        }
                        root.push(node);
                    }
                    // always process comments before deciding if finished
                    if (parserInput.finished) {
                        break;
                    }
                    if (parserInput.peek('}')) {
                        break;
                    }
                    node = this.extendRule();
                    if (node) {
                        root = root.concat(node);
                        continue;
                    }
                    node = mixin.definition() || this.declaration() || mixin.call(false, false) ||
                        this.ruleset() || this.variableCall() || this.entities.call() || this.atrule();
                    if (node) {
                        root.push(node);
                    }
                    else {
                        var foundSemiColon = false;
                        while (parserInput.$char(';')) {
                            foundSemiColon = true;
                        }
                        if (!foundSemiColon) {
                            break;
                        }
                    }
                }
                return root;
            },
            // comments are collected by the main parsing mechanism and then assigned to nodes
            // where the current structure allows it
            comment: function () {
                if (parserInput.commentStore.length) {
                    var comment = parserInput.commentStore.shift();
                    return new (tree_1.default.Comment)(comment.text, comment.isLineComment, comment.index, fileInfo);
                }
            },
            //
            // Entities are tokens which can be found inside an Expression
            //
            entities: {
                mixinLookup: function () {
                    return parsers.mixin.call(true, true);
                },
                //
                // A string, which supports escaping " and '
                //
                //     "milky way" 'he\'s the one!'
                //
                quoted: function (forceEscaped) {
                    var str;
                    var index = parserInput.i;
                    var isEscaped = false;
                    parserInput.save();
                    if (parserInput.$char('~')) {
                        isEscaped = true;
                    }
                    else if (forceEscaped) {
                        parserInput.restore();
                        return;
                    }
                    str = parserInput.$quoted();
                    if (!str) {
                        parserInput.restore();
                        return;
                    }
                    parserInput.forget();
                    return new (tree_1.default.Quoted)(str.charAt(0), str.substr(1, str.length - 2), isEscaped, index, fileInfo);
                },
                //
                // A catch-all word, such as:
                //
                //     black border-collapse
                //
                keyword: function () {
                    var k = parserInput.$char('%') || parserInput.$re(/^\[?(?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+\]?/);
                    if (k) {
                        return tree_1.default.Color.fromKeyword(k) || new (tree_1.default.Keyword)(k);
                    }
                },
                //
                // A function call
                //
                //     rgb(255, 0, 255)
                //
                // The arguments are parsed with the `entities.arguments` parser.
                //
                call: function () {
                    var name;
                    var args;
                    var func;
                    var index = parserInput.i;
                    // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                    if (parserInput.peek(/^url\(/i)) {
                        return;
                    }
                    parserInput.save();
                    name = parserInput.$re(/^([\w-]+|%|progid:[\w\.]+)\(/);
                    if (!name) {
                        parserInput.forget();
                        return;
                    }
                    name = name[1];
                    func = this.customFuncCall(name);
                    if (func) {
                        args = func.parse();
                        if (args &amp;&amp; func.stop) {
                            parserInput.forget();
                            return args;
                        }
                    }
                    args = this.arguments(args);
                    if (!parserInput.$char(')')) {
                        parserInput.restore('Could not parse call arguments or missing \')\'');
                        return;
                    }
                    parserInput.forget();
                    return new (tree_1.default.Call)(name, args, index, fileInfo);
                },
                //
                // Parsing rules for functions with non-standard args, e.g.:
                //
                //     boolean(not(2 > 1))
                //
                //     This is a quick prototype, to be modified/improved when
                //     more custom-parsed funcs come (e.g. `selector(...)`)
                //
                customFuncCall: function (name) {
                    /* Ideally the table is to be moved out of here for faster perf.,
                       but it's quite tricky since it relies on all these `parsers`
                       and `expect` available only here */
                    return {
                        alpha: f(parsers.ieAlpha, true),
                        boolean: f(condition),
                        'if': f(condition)
                    }[name.toLowerCase()];
                    function f(parse, stop) {
                        return {
                            parse: parse,
                            stop: stop // when true - stop after parse() and return its result, 
                            // otherwise continue for plain args
                        };
                    }
                    function condition() {
                        return [expect(parsers.condition, 'expected condition')];
                    }
                },
                arguments: function (prevArgs) {
                    var argsComma = prevArgs || [];
                    var argsSemiColon = [];
                    var isSemiColonSeparated;
                    var value;
                    parserInput.save();
                    while (true) {
                        if (prevArgs) {
                            prevArgs = false;
                        }
                        else {
                            value = parsers.detachedRuleset() || this.assignment() || parsers.expression();
                            if (!value) {
                                break;
                            }
                            if (value.value &amp;&amp; value.value.length == 1) {
                                value = value.value[0];
                            }
                            argsComma.push(value);
                        }
                        if (parserInput.$char(',')) {
                            continue;
                        }
                        if (parserInput.$char(';') || isSemiColonSeparated) {
                            isSemiColonSeparated = true;
                            value = (argsComma.length &lt; 1) ? argsComma[0]
                                : new tree_1.default.Value(argsComma);
                            argsSemiColon.push(value);
                            argsComma = [];
                        }
                    }
                    parserInput.forget();
                    return isSemiColonSeparated ? argsSemiColon : argsComma;
                },
                literal: function () {
                    return this.dimension() ||
                        this.color() ||
                        this.quoted() ||
                        this.unicodeDescriptor();
                },
                // Assignments are argument entities for calls.
                // They are present in ie filter properties as shown below.
                //
                //     filter: progid:DXImageTransform.Microsoft.Alpha( *opacity=50* )
                //
                assignment: function () {
                    var key;
                    var value;
                    parserInput.save();
                    key = parserInput.$re(/^\w+(?=\s?=)/i);
                    if (!key) {
                        parserInput.restore();
                        return;
                    }
                    if (!parserInput.$char('=')) {
                        parserInput.restore();
                        return;
                    }
                    value = parsers.entity();
                    if (value) {
                        parserInput.forget();
                        return new (tree_1.default.Assignment)(key, value);
                    }
                    else {
                        parserInput.restore();
                    }
                },
                //
                // Parse url() tokens
                //
                // We use a specific rule for urls, because they don't really behave like
                // standard function calls. The difference is that the argument doesn't have
                // to be enclosed within a string, so it can't be parsed as an Expression.
                //
                url: function () {
                    var value;
                    var index = parserInput.i;
                    parserInput.autoCommentAbsorb = false;
                    if (!parserInput.$str('url(')) {
                        parserInput.autoCommentAbsorb = true;
                        return;
                    }
                    value = this.quoted() || this.variable() || this.property() ||
                        parserInput.$re(/^(?:(?:\\[\(\)'"])|[^\(\)'"])+/) || '';
                    parserInput.autoCommentAbsorb = true;
                    expectChar(')');
                    return new (tree_1.default.URL)((value.value != null ||
                        value instanceof tree_1.default.Variable ||
                        value instanceof tree_1.default.Property) ?
                        value : new (tree_1.default.Anonymous)(value, index), index, fileInfo);
                },
                //
                // A Variable entity, such as `@fink`, in
                //
                //     width: @fink + 2px
                //
                // We use a different parser for variable definitions,
                // see `parsers.variable`.
                //
                variable: function () {
                    var ch;
                    var name;
                    var index = parserInput.i;
                    parserInput.save();
                    if (parserInput.currentChar() === '@' &amp;&amp; (name = parserInput.$re(/^@@?[\w-]+/))) {
                        ch = parserInput.currentChar();
                        if (ch === '(' || ch === '[' &amp;&amp; !parserInput.prevChar().match(/^\s/)) {
                            // this may be a VariableCall lookup
                            var result = parsers.variableCall(name);
                            if (result) {
                                parserInput.forget();
                                return result;
                            }
                        }
                        parserInput.forget();
                        return new (tree_1.default.Variable)(name, index, fileInfo);
                    }
                    parserInput.restore();
                },
                // A variable entity using the protective {} e.g. @{var}
                variableCurly: function () {
                    var curly;
                    var index = parserInput.i;
                    if (parserInput.currentChar() === '@' &amp;&amp; (curly = parserInput.$re(/^@\{([\w-]+)\}/))) {
                        return new (tree_1.default.Variable)("@" + curly[1], index, fileInfo);
                    }
                },
                //
                // A Property accessor, such as `$color`, in
                //
                //     background-color: $color
                //
                property: function () {
                    var name;
                    var index = parserInput.i;
                    if (parserInput.currentChar() === '$' &amp;&amp; (name = parserInput.$re(/^\$[\w-]+/))) {
                        return new (tree_1.default.Property)(name, index, fileInfo);
                    }
                },
                // A property entity useing the protective {} e.g. ${prop}
                propertyCurly: function () {
                    var curly;
                    var index = parserInput.i;
                    if (parserInput.currentChar() === '$' &amp;&amp; (curly = parserInput.$re(/^\$\{([\w-]+)\}/))) {
                        return new (tree_1.default.Property)("$" + curly[1], index, fileInfo);
                    }
                },
                //
                // A Hexadecimal color
                //
                //     #4F3C2F
                //
                // `rgb` and `hsl` colors are parsed through the `entities.call` parser.
                //
                color: function () {
                    var rgb;
                    parserInput.save();
                    if (parserInput.currentChar() === '#' &amp;&amp; (rgb = parserInput.$re(/^#([A-Fa-f0-9]{8}|[A-Fa-f0-9]{6}|[A-Fa-f0-9]{3,4})([\w.#\[])?/))) {
                        if (!rgb[2]) {
                            parserInput.forget();
                            return new (tree_1.default.Color)(rgb[1], undefined, rgb[0]);
                        }
                    }
                    parserInput.restore();
                },
                colorKeyword: function () {
                    parserInput.save();
                    var autoCommentAbsorb = parserInput.autoCommentAbsorb;
                    parserInput.autoCommentAbsorb = false;
                    var k = parserInput.$re(/^[_A-Za-z-][_A-Za-z0-9-]+/);
                    parserInput.autoCommentAbsorb = autoCommentAbsorb;
                    if (!k) {
                        parserInput.forget();
                        return;
                    }
                    parserInput.restore();
                    var color = tree_1.default.Color.fromKeyword(k);
                    if (color) {
                        parserInput.$str(k);
                        return color;
                    }
                },
                //
                // A Dimension, that is, a number and a unit
                //
                //     0.5em 95%
                //
                dimension: function () {
                    if (parserInput.peekNotNumeric()) {
                        return;
                    }
                    var value = parserInput.$re(/^([+-]?\d*\.?\d+)(%|[a-z_]+)?/i);
                    if (value) {
                        return new (tree_1.default.Dimension)(value[1], value[2]);
                    }
                },
                //
                // A unicode descriptor, as is used in unicode-range
                //
                // U+0??  or U+00A1-00A9
                //
                unicodeDescriptor: function () {
                    var ud;
                    ud = parserInput.$re(/^U\+[0-9a-fA-F?]+(\-[0-9a-fA-F?]+)?/);
                    if (ud) {
                        return new (tree_1.default.UnicodeDescriptor)(ud[0]);
                    }
                },
                //
                // JavaScript code to be evaluated
                //
                //     `window.location.href`
                //
                javascript: function () {
                    var js;
                    var index = parserInput.i;
                    parserInput.save();
                    var escape = parserInput.$char('~');
                    var jsQuote = parserInput.$char('`');
                    if (!jsQuote) {
                        parserInput.restore();
                        return;
                    }
                    js = parserInput.$re(/^[^`]*`/);
                    if (js) {
                        parserInput.forget();
                        return new (tree_1.default.JavaScript)(js.substr(0, js.length - 1), Boolean(escape), index, fileInfo);
                    }
                    parserInput.restore('invalid javascript definition');
                }
            },
            //
            // The variable part of a variable definition. Used in the `rule` parser
            //
            //     @fink:
            //
            variable: function () {
                var name;
                if (parserInput.currentChar() === '@' &amp;&amp; (name = parserInput.$re(/^(@[\w-]+)\s*:/))) {
                    return name[1];
                }
            },
            //
            // Call a variable value to retrieve a detached ruleset
            // or a value from a detached ruleset's rules.
            //
            //     @fink();
            //     @fink;
            //     color: @fink[@color];
            //
            variableCall: function (parsedName) {
                var lookups;
                var i = parserInput.i;
                var inValue = !!parsedName;
                var name = parsedName;
                parserInput.save();
                if (name || (parserInput.currentChar() === '@'
                    &amp;&amp; (name = parserInput.$re(/^(@[\w-]+)(\(\s*\))?/)))) {
                    lookups = this.mixin.ruleLookups();
                    if (!lookups &amp;&amp; ((inValue &amp;&amp; parserInput.$str('()') !== '()') || (name[2] !== '()'))) {
                        parserInput.restore('Missing \'[...]\' lookup in variable call');
                        return;
                    }
                    if (!inValue) {
                        name = name[1];
                    }
                    var call = new tree_1.default.VariableCall(name, i, fileInfo);
                    if (!inValue &amp;&amp; parsers.end()) {
                        parserInput.forget();
                        return call;
                    }
                    else {
                        parserInput.forget();
                        return new tree_1.default.NamespaceValue(call, lookups, i, fileInfo);
                    }
                }
                parserInput.restore();
            },
            //
            // extend syntax - used to extend selectors
            //
            extend: function (isRule) {
                var elements;
                var e;
                var index = parserInput.i;
                var option;
                var extendList;
                var extend;
                if (!parserInput.$str(isRule ? '&amp;:extend(' : ':extend(')) {
                    return;
                }
                do {
                    option = null;
                    elements = null;
                    while (!(option = parserInput.$re(/^(all)(?=\s*(\)|,))/))) {
                        e = this.element();
                        if (!e) {
                            break;
                        }
                        if (elements) {
                            elements.push(e);
                        }
                        else {
                            elements = [e];
                        }
                    }
                    option = option &amp;&amp; option[1];
                    if (!elements) {
                        error('Missing target selector for :extend().');
                    }
                    extend = new (tree_1.default.Extend)(new (tree_1.default.Selector)(elements), option, index, fileInfo);
                    if (extendList) {
                        extendList.push(extend);
                    }
                    else {
                        extendList = [extend];
                    }
                } while (parserInput.$char(','));
                expect(/^\)/);
                if (isRule) {
                    expect(/^;/);
                }
                return extendList;
            },
            //
            // extendRule - used in a rule to extend all the parent selectors
            //
            extendRule: function () {
                return this.extend(true);
            },
            //
            // Mixins
            //
            mixin: {
                //
                // A Mixin call, with an optional argument list
                //
                //     #mixins > .square(#fff);
                //     #mixins.square(#fff);
                //     .rounded(4px, black);
                //     .button;
                //
                // We can lookup / return a value using the lookup syntax:
                //
                //     color: #mixin.square(#fff)[@color];
                //
                // The `while` loop is there because mixins can be
                // namespaced, but we only support the child and descendant
                // selector for now.
                //
                call: function (inValue, getLookup) {
                    var s = parserInput.currentChar();
                    var important = false;
                    var lookups;
                    var index = parserInput.i;
                    var elements;
                    var args;
                    var hasParens;
                    if (s !== '.' &amp;&amp; s !== '#') {
                        return;
                    }
                    parserInput.save(); // stop us absorbing part of an invalid selector
                    elements = this.elements();
                    if (elements) {
                        if (parserInput.$char('(')) {
                            args = this.args(true).args;
                            expectChar(')');
                            hasParens = true;
                        }
                        if (getLookup !== false) {
                            lookups = this.ruleLookups();
                        }
                        if (getLookup === true &amp;&amp; !lookups) {
                            parserInput.restore();
                            return;
                        }
                        if (inValue &amp;&amp; !lookups &amp;&amp; !hasParens) {
                            // This isn't a valid in-value mixin call
                            parserInput.restore();
                            return;
                        }
                        if (!inValue &amp;&amp; parsers.important()) {
                            important = true;
                        }
                        if (inValue || parsers.end()) {
                            parserInput.forget();
                            var mixin = new (tree_1.default.mixin.Call)(elements, args, index, fileInfo, !lookups &amp;&amp; important);
                            if (lookups) {
                                return new tree_1.default.NamespaceValue(mixin, lookups);
                            }
                            else {
                                return mixin;
                            }
                        }
                    }
                    parserInput.restore();
                },
                /**
                 * Matching elements for mixins
                 * (Start with . or # and can have > )
                 */
                elements: function () {
                    var elements;
                    var e;
                    var c;
                    var elem;
                    var elemIndex;
                    var re = /^[#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/;
                    while (true) {
                        elemIndex = parserInput.i;
                        e = parserInput.$re(re);
                        if (!e) {
                            break;
                        }
                        elem = new (tree_1.default.Element)(c, e, false, elemIndex, fileInfo);
                        if (elements) {
                            elements.push(elem);
                        }
                        else {
                            elements = [elem];
                        }
                        c = parserInput.$char('>');
                    }
                    return elements;
                },
                args: function (isCall) {
                    var entities = parsers.entities;
                    var returner = { args: null, variadic: false };
                    var expressions = [];
                    var argsSemiColon = [];
                    var argsComma = [];
                    var isSemiColonSeparated;
                    var expressionContainsNamed;
                    var name;
                    var nameLoop;
                    var value;
                    var arg;
                    var expand;
                    var hasSep = true;
                    parserInput.save();
                    while (true) {
                        if (isCall) {
                            arg = parsers.detachedRuleset() || parsers.expression();
                        }
                        else {
                            parserInput.commentStore.length = 0;
                            if (parserInput.$str('...')) {
                                returner.variadic = true;
                                if (parserInput.$char(';') &amp;&amp; !isSemiColonSeparated) {
                                    isSemiColonSeparated = true;
                                }
                                (isSemiColonSeparated ? argsSemiColon : argsComma)
                                    .push({ variadic: true });
                                break;
                            }
                            arg = entities.variable() || entities.property() || entities.literal() || entities.keyword() || this.call(true);
                        }
                        if (!arg || !hasSep) {
                            break;
                        }
                        nameLoop = null;
                        if (arg.throwAwayComments) {
                            arg.throwAwayComments();
                        }
                        value = arg;
                        var val = null;
                        if (isCall) {
                            // Variable
                            if (arg.value &amp;&amp; arg.value.length == 1) {
                                val = arg.value[0];
                            }
                        }
                        else {
                            val = arg;
                        }
                        if (val &amp;&amp; (val instanceof tree_1.default.Variable || val instanceof tree_1.default.Property)) {
                            if (parserInput.$char(':')) {
                                if (expressions.length > 0) {
                                    if (isSemiColonSeparated) {
                                        error('Cannot mix ; and , as delimiter types');
                                    }
                                    expressionContainsNamed = true;
                                }
                                value = parsers.detachedRuleset() || parsers.expression();
                                if (!value) {
                                    if (isCall) {
                                        error('could not understand value for named argument');
                                    }
                                    else {
                                        parserInput.restore();
                                        returner.args = [];
                                        return returner;
                                    }
                                }
                                nameLoop = (name = val.name);
                            }
                            else if (parserInput.$str('...')) {
                                if (!isCall) {
                                    returner.variadic = true;
                                    if (parserInput.$char(';') &amp;&amp; !isSemiColonSeparated) {
                                        isSemiColonSeparated = true;
                                    }
                                    (isSemiColonSeparated ? argsSemiColon : argsComma)
                                        .push({ name: arg.name, variadic: true });
                                    break;
                                }
                                else {
                                    expand = true;
                                }
                            }
                            else if (!isCall) {
                                name = nameLoop = val.name;
                                value = null;
                            }
                        }
                        if (value) {
                            expressions.push(value);
                        }
                        argsComma.push({ name: nameLoop, value: value, expand: expand });
                        if (parserInput.$char(',')) {
                            hasSep = true;
                            continue;
                        }
                        hasSep = parserInput.$char(';') === ';';
                        if (hasSep || isSemiColonSeparated) {
                            if (expressionContainsNamed) {
                                error('Cannot mix ; and , as delimiter types');
                            }
                            isSemiColonSeparated = true;
                            if (expressions.length > 1) {
                                value = new (tree_1.default.Value)(expressions);
                            }
                            argsSemiColon.push({ name: name, value: value, expand: expand });
                            name = null;
                            expressions = [];
                            expressionContainsNamed = false;
                        }
                    }
                    parserInput.forget();
                    returner.args = isSemiColonSeparated ? argsSemiColon : argsComma;
                    return returner;
                },
                //
                // A Mixin definition, with a list of parameters
                //
                //     .rounded (@radius: 2px, @color) {
                //        ...
                //     }
                //
                // Until we have a finer grained state-machine, we have to
                // do a look-ahead, to make sure we don't have a mixin call.
                // See the `rule` function for more information.
                //
                // We start by matching `.rounded (`, and then proceed on to
                // the argument list, which has optional default values.
                // We store the parameters in `params`, with a `value` key,
                // if there is a value, such as in the case of `@radius`.
                //
                // Once we've got our params list, and a closing `)`, we parse
                // the `{...}` block.
                //
                definition: function () {
                    var name;
                    var params = [];
                    var match;
                    var ruleset;
                    var cond;
                    var variadic = false;
                    if ((parserInput.currentChar() !== '.' &amp;&amp; parserInput.currentChar() !== '#') ||
                        parserInput.peek(/^[^{]*\}/)) {
                        return;
                    }
                    parserInput.save();
                    match = parserInput.$re(/^([#.](?:[\w-]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+)\s*\(/);
                    if (match) {
                        name = match[1];
                        var argInfo = this.args(false);
                        params = argInfo.args;
                        variadic = argInfo.variadic;
                        // .mixincall("@{a}");
                        // looks a bit like a mixin definition..
                        // also
                        // .mixincall(@a: {rule: set;});
                        // so we have to be nice and restore
                        if (!parserInput.$char(')')) {
                            parserInput.restore('Missing closing \')\'');
                            return;
                        }
                        parserInput.commentStore.length = 0;
                        if (parserInput.$str('when')) { // Guard
                            cond = expect(parsers.conditions, 'expected condition');
                        }
                        ruleset = parsers.block();
                        if (ruleset) {
                            parserInput.forget();
                            return new (tree_1.default.mixin.Definition)(name, params, ruleset, cond, variadic);
                        }
                        else {
                            parserInput.restore();
                        }
                    }
                    else {
                        parserInput.restore();
                    }
                },
                ruleLookups: function () {
                    var rule;
                    var args;
                    var lookups = [];
                    if (parserInput.currentChar() !== '[') {
                        return;
                    }
                    while (true) {
                        parserInput.save();
                        args = null;
                        rule = this.lookupValue();
                        if (!rule &amp;&amp; rule !== '') {
                            parserInput.restore();
                            break;
                        }
                        lookups.push(rule);
                        parserInput.forget();
                    }
                    if (lookups.length > 0) {
                        return lookups;
                    }
                },
                lookupValue: function () {
                    parserInput.save();
                    if (!parserInput.$char('[')) {
                        parserInput.restore();
                        return;
                    }
                    var name = parserInput.$re(/^(?:[@$]{0,2})[_a-zA-Z0-9-]*/);
                    if (!parserInput.$char(']')) {
                        parserInput.restore();
                        return;
                    }
                    if (name || name === '') {
                        parserInput.forget();
                        return name;
                    }
                    parserInput.restore();
                }
            },
            //
            // Entities are the smallest recognized token,
            // and can be found inside a rule's value.
            //
            entity: function () {
                var entities = this.entities;
                return this.comment() || entities.literal() || entities.variable() || entities.url() ||
                    entities.property() || entities.call() || entities.keyword() || this.mixin.call(true) ||
                    entities.javascript();
            },
            //
            // A Declaration terminator. Note that we use `peek()` to check for '}',
            // because the `block` rule will be expecting it, but we still need to make sure
            // it's there, if ';' was omitted.
            //
            end: function () {
                return parserInput.$char(';') || parserInput.peek('}');
            },
            //
            // IE's alpha function
            //
            //     alpha(opacity=88)
            //
            ieAlpha: function () {
                var value;
                // http://jsperf.com/case-insensitive-regex-vs-strtolower-then-regex/18
                if (!parserInput.$re(/^opacity=/i)) {
                    return;
                }
                value = parserInput.$re(/^\d+/);
                if (!value) {
                    value = expect(parsers.entities.variable, 'Could not parse alpha');
                    value = "@{" + value.name.slice(1) + "}";
                }
                expectChar(')');
                return new tree_1.default.Quoted('', "alpha(opacity=" + value + ")");
            },
            //
            // A Selector Element
            //
            //     div
            //     + h1
            //     #socks
            //     input[type="text"]
            //
            // Elements are the building blocks for Selectors,
            // they are made out of a `Combinator` (see combinator rule),
            // and an element name, such as a tag a class, or `*`.
            //
            element: function () {
                var e;
                var c;
                var v;
                var index = parserInput.i;
                c = this.combinator();
                e = parserInput.$re(/^(?:\d+\.\d+|\d+)%/) ||
                    parserInput.$re(/^(?:[.#]?|:*)(?:[\w-]|[^\x00-\x9f]|\\(?:[A-Fa-f0-9]{1,6} ?|[^A-Fa-f0-9]))+/) ||
                    parserInput.$char('*') || parserInput.$char('&amp;') || this.attribute() ||
                    parserInput.$re(/^\([^&amp;()@]+\)/) || parserInput.$re(/^[\.#:](?=@)/) ||
                    this.entities.variableCurly();
                if (!e) {
                    parserInput.save();
                    if (parserInput.$char('(')) {
                        if ((v = this.selector(false)) &amp;&amp; parserInput.$char(')')) {
                            e = new (tree_1.default.Paren)(v);
                            parserInput.forget();
                        }
                        else {
                            parserInput.restore('Missing closing \')\'');
                        }
                    }
                    else {
                        parserInput.forget();
                    }
                }
                if (e) {
                    return new (tree_1.default.Element)(c, e, e instanceof tree_1.default.Variable, index, fileInfo);
                }
            },
            //
            // Combinators combine elements together, in a Selector.
            //
            // Because our parser isn't white-space sensitive, special care
            // has to be taken, when parsing the descendant combinator, ` `,
            // as it's an empty space. We have to check the previous character
            // in the input, to see if it's a ` ` character. More info on how
            // we deal with this in *combinator.js*.
            //
            combinator: function () {
                var c = parserInput.currentChar();
                if (c === '/') {
                    parserInput.save();
                    var slashedCombinator = parserInput.$re(/^\/[a-z]+\//i);
                    if (slashedCombinator) {
                        parserInput.forget();
                        return new (tree_1.default.Combinator)(slashedCombinator);
                    }
                    parserInput.restore();
                }
                if (c === '>' || c === '+' || c === '~' || c === '|' || c === '^') {
                    parserInput.i++;
                    if (c === '^' &amp;&amp; parserInput.currentChar() === '^') {
                        c = '^^';
                        parserInput.i++;
                    }
                    while (parserInput.isWhitespace()) {
                        parserInput.i++;
                    }
                    return new (tree_1.default.Combinator)(c);
                }
                else if (parserInput.isWhitespace(-1)) {
                    return new (tree_1.default.Combinator)(' ');
                }
                else {
                    return new (tree_1.default.Combinator)(null);
                }
            },
            //
            // A CSS Selector
            // with less extensions e.g. the ability to extend and guard
            //
            //     .class > div + h1
            //     li a:hover
            //
            // Selectors are made out of one or more Elements, see above.
            //
            selector: function (isLess) {
                var index = parserInput.i;
                var elements;
                var extendList;
                var c;
                var e;
                var allExtends;
                var when;
                var condition;
                isLess = isLess !== false;
                while ((isLess &amp;&amp; (extendList = this.extend())) || (isLess &amp;&amp; (when = parserInput.$str('when'))) || (e = this.element())) {
                    if (when) {
                        condition = expect(this.conditions, 'expected condition');
                    }
                    else if (condition) {
                        error('CSS guard can only be used at the end of selector');
                    }
                    else if (extendList) {
                        if (allExtends) {
                            allExtends = allExtends.concat(extendList);
                        }
                        else {
                            allExtends = extendList;
                        }
                    }
                    else {
                        if (allExtends) {
                            error('Extend can only be used at the end of selector');
                        }
                        c = parserInput.currentChar();
                        if (elements) {
                            elements.push(e);
                        }
                        else {
                            elements = [e];
                        }
                        e = null;
                    }
                    if (c === '{' || c === '}' || c === ';' || c === ',' || c === ')') {
                        break;
                    }
                }
                if (elements) {
                    return new (tree_1.default.Selector)(elements, allExtends, condition, index, fileInfo);
                }
                if (allExtends) {
                    error('Extend must be used to extend a selector, it cannot be used on its own');
                }
            },
            selectors: function () {
                var s;
                var selectors;
                while (true) {
                    s = this.selector();
                    if (!s) {
                        break;
                    }
                    if (selectors) {
                        selectors.push(s);
                    }
                    else {
                        selectors = [s];
                    }
                    parserInput.commentStore.length = 0;
                    if (s.condition &amp;&amp; selectors.length > 1) {
                        error("Guards are only currently allowed on a single selector.");
                    }
                    if (!parserInput.$char(',')) {
                        break;
                    }
                    if (s.condition) {
                        error("Guards are only currently allowed on a single selector.");
                    }
                    parserInput.commentStore.length = 0;
                }
                return selectors;
            },
            attribute: function () {
                if (!parserInput.$char('[')) {
                    return;
                }
                var entities = this.entities;
                var key;
                var val;
                var op;
                if (!(key = entities.variableCurly())) {
                    key = expect(/^(?:[_A-Za-z0-9-\*]*\|)?(?:[_A-Za-z0-9-]|\\.)+/);
                }
                op = parserInput.$re(/^[|~*$^]?=/);
                if (op) {
                    val = entities.quoted() || parserInput.$re(/^[0-9]+%/) || parserInput.$re(/^[\w-]+/) || entities.variableCurly();
                }
                expectChar(']');
                return new (tree_1.default.Attribute)(key, op, val);
            },
            //
            // The `block` rule is used by `ruleset` and `mixin.definition`.
            // It's a wrapper around the `primary` rule, with added `{}`.
            //
            block: function () {
                var content;
                if (parserInput.$char('{') &amp;&amp; (content = this.primary()) &amp;&amp; parserInput.$char('}')) {
                    return content;
                }
            },
            blockRuleset: function () {
                var block = this.block();
                if (block) {
                    block = new tree_1.default.Ruleset(null, block);
                }
                return block;
            },
            detachedRuleset: function () {
                var argInfo;
                var params;
                var variadic;
                parserInput.save();
                if (parserInput.$re(/^[.#]\(/)) {
                    /**
                     * DR args currently only implemented for each() function, and not
                     * yet settable as `@dr: #(@arg) {}`
                     * This should be done when DRs are merged with mixins.
                     * See: https://github.com/less/less-meta/issues/16
                     */
                    argInfo = this.mixin.args(false);
                    params = argInfo.args;
                    variadic = argInfo.variadic;
                    if (!parserInput.$char(')')) {
                        parserInput.restore();
                        return;
                    }
                }
                var blockRuleset = this.blockRuleset();
                if (blockRuleset) {
                    parserInput.forget();
                    if (params) {
                        return new tree_1.default.mixin.Definition(null, params, blockRuleset, null, variadic);
                    }
                    return new tree_1.default.DetachedRuleset(blockRuleset);
                }
                parserInput.restore();
            },
            //
            // div, .class, body > p {...}
            //
            ruleset: function () {
                var selectors;
                var rules;
                var debugInfo;
                parserInput.save();
                if (context.dumpLineNumbers) {
                    debugInfo = getDebugInfo(parserInput.i);
                }
                selectors = this.selectors();
                if (selectors &amp;&amp; (rules = this.block())) {
                    parserInput.forget();
                    var ruleset = new (tree_1.default.Ruleset)(selectors, rules, context.strictImports);
                    if (context.dumpLineNumbers) {
                        ruleset.debugInfo = debugInfo;
                    }
                    return ruleset;
                }
                else {
                    parserInput.restore();
                }
            },
            declaration: function () {
                var name;
                var value;
                var index = parserInput.i;
                var hasDR;
                var c = parserInput.currentChar();
                var important;
                var merge;
                var isVariable;
                if (c === '.' || c === '#' || c === '&amp;' || c === ':') {
                    return;
                }
                parserInput.save();
                name = this.variable() || this.ruleProperty();
                if (name) {
                    isVariable = typeof name === 'string';
                    if (isVariable) {
                        value = this.detachedRuleset();
                        if (value) {
                            hasDR = true;
                        }
                    }
                    parserInput.commentStore.length = 0;
                    if (!value) {
                        // a name returned by this.ruleProperty() is always an array of the form:
                        // [string-1, ..., string-n, ""] or [string-1, ..., string-n, "+"]
                        // where each item is a tree.Keyword or tree.Variable
                        merge = !isVariable &amp;&amp; name.length > 1 &amp;&amp; name.pop().value;
                        // Custom property values get permissive parsing
                        if (name[0].value &amp;&amp; name[0].value.slice(0, 2) === '--') {
                            value = this.permissiveValue();
                        }
                        // Try to store values as anonymous
                        // If we need the value later we'll re-parse it in ruleset.parseValue
                        else {
                            value = this.anonymousValue();
                        }
                        if (value) {
                            parserInput.forget();
                            // anonymous values absorb the end ';' which is required for them to work
                            return new (tree_1.default.Declaration)(name, value, false, merge, index, fileInfo);
                        }
                        if (!value) {
                            value = this.value();
                        }
                        if (value) {
                            important = this.important();
                        }
                        else if (isVariable) {
                            // As a last resort, try permissiveValue
                            value = this.permissiveValue();
                        }
                    }
                    if (value &amp;&amp; (this.end() || hasDR)) {
                        parserInput.forget();
                        return new (tree_1.default.Declaration)(name, value, important, merge, index, fileInfo);
                    }
                    else {
                        parserInput.restore();
                    }
                }
                else {
                    parserInput.restore();
                }
            },
            anonymousValue: function () {
                var index = parserInput.i;
                var match = parserInput.$re(/^([^.#@\$+\/'"*`(;{}-]*);/);
                if (match) {
                    return new (tree_1.default.Anonymous)(match[1], index);
                }
            },
            /**
             * Used for custom properties, at-rules, and variables (as fallback)
             * Parses almost anything inside of {} [] () "" blocks
             * until it reaches outer-most tokens.
             *
             * First, it will try to parse comments and entities to reach
             * the end. This is mostly like the Expression parser except no
             * math is allowed.
             */
            permissiveValue: function (untilTokens) {
                var i;
                var e;
                var done;
                var value;
                var tok = untilTokens || ';';
                var index = parserInput.i;
                var result = [];
                function testCurrentChar() {
                    var char = parserInput.currentChar();
                    if (typeof tok === 'string') {
                        return char === tok;
                    }
                    else {
                        return tok.test(char);
                    }
                }
                if (testCurrentChar()) {
                    return;
                }
                value = [];
                do {
                    e = this.comment();
                    if (e) {
                        value.push(e);
                        continue;
                    }
                    e = this.entity();
                    if (e) {
                        value.push(e);
                    }
                } while (e);
                done = testCurrentChar();
                if (value.length > 0) {
                    value = new (tree_1.default.Expression)(value);
                    if (done) {
                        return value;
                    }
                    else {
                        result.push(value);
                    }
                    // Preserve space before $parseUntil as it will not
                    if (parserInput.prevChar() === ' ') {
                        result.push(new tree_1.default.Anonymous(' ', index));
                    }
                }
                parserInput.save();
                value = parserInput.$parseUntil(tok);
                if (value) {
                    if (typeof value === 'string') {
                        error("Expected '" + value + "'", 'Parse');
                    }
                    if (value.length === 1 &amp;&amp; value[0] === ' ') {
                        parserInput.forget();
                        return new tree_1.default.Anonymous('', index);
                    }
                    var item = void 0;
                    for (i = 0; i &lt; value.length; i++) {
                        item = value[i];
                        if (Array.isArray(item)) {
                            // Treat actual quotes as normal quoted values
                            result.push(new tree_1.default.Quoted(item[0], item[1], true, index, fileInfo));
                        }
                        else {
                            if (i === value.length - 1) {
                                item = item.trim();
                            }
                            // Treat like quoted values, but replace vars like unquoted expressions
                            var quote = new tree_1.default.Quoted('\'', item, true, index, fileInfo);
                            quote.variableRegex = /@([\w-]+)/g;
                            quote.propRegex = /\$([\w-]+)/g;
                            result.push(quote);
                        }
                    }
                    parserInput.forget();
                    return new tree_1.default.Expression(result, true);
                }
                parserInput.restore();
            },
            //
            // An @import atrule
            //
            //     @import "lib";
            //
            // Depending on our environment, importing is done differently:
            // In the browser, it's an XHR request, in Node, it would be a
            // file-system operation. The function used for importing is
            // stored in `import`, which we pass to the Import constructor.
            //
            'import': function () {
                var path;
                var features;
                var index = parserInput.i;
                var dir = parserInput.$re(/^@import?\s+/);
                if (dir) {
                    var options = (dir ? this.importOptions() : null) || {};
                    if ((path = this.entities.quoted() || this.entities.url())) {
                        features = this.mediaFeatures();
                        if (!parserInput.$char(';')) {
                            parserInput.i = index;
                            error('missing semi-colon or unrecognised media features on import');
                        }
                        features = features &amp;&amp; new (tree_1.default.Value)(features);
                        return new (tree_1.default.Import)(path, features, options, index, fileInfo);
                    }
                    else {
                        parserInput.i = index;
                        error('malformed import statement');
                    }
                }
            },
            importOptions: function () {
                var o;
                var options = {};
                var optionName;
                var value;
                // list of options, surrounded by parens
                if (!parserInput.$char('(')) {
                    return null;
                }
                do {
                    o = this.importOption();
                    if (o) {
                        optionName = o;
                        value = true;
                        switch (optionName) {
                            case 'css':
                                optionName = 'less';
                                value = false;
                                break;
                            case 'once':
                                optionName = 'multiple';
                                value = false;
                                break;
                        }
                        options[optionName] = value;
                        if (!parserInput.$char(',')) {
                            break;
                        }
                    }
                } while (o);
                expectChar(')');
                return options;
            },
            importOption: function () {
                var opt = parserInput.$re(/^(less|css|multiple|once|inline|reference|optional)/);
                if (opt) {
                    return opt[1];
                }
            },
            mediaFeature: function () {
                var entities = this.entities;
                var nodes = [];
                var e;
                var p;
                parserInput.save();
                do {
                    e = entities.keyword() || entities.variable() || entities.mixinLookup();
                    if (e) {
                        nodes.push(e);
                    }
                    else if (parserInput.$char('(')) {
                        p = this.property();
                        e = this.value();
                        if (parserInput.$char(')')) {
                            if (p &amp;&amp; e) {
                                nodes.push(new (tree_1.default.Paren)(new (tree_1.default.Declaration)(p, e, null, null, parserInput.i, fileInfo, true)));
                            }
                            else if (e) {
                                nodes.push(new (tree_1.default.Paren)(e));
                            }
                            else {
                                error('badly formed media feature definition');
                            }
                        }
                        else {
                            error('Missing closing \')\'', 'Parse');
                        }
                    }
                } while (e);
                parserInput.forget();
                if (nodes.length > 0) {
                    return new (tree_1.default.Expression)(nodes);
                }
            },
            mediaFeatures: function () {
                var entities = this.entities;
                var features = [];
                var e;
                do {
                    e = this.mediaFeature();
                    if (e) {
                        features.push(e);
                        if (!parserInput.$char(',')) {
                            break;
                        }
                    }
                    else {
                        e = entities.variable() || entities.mixinLookup();
                        if (e) {
                            features.push(e);
                            if (!parserInput.$char(',')) {
                                break;
                            }
                        }
                    }
                } while (e);
                return features.length > 0 ? features : null;
            },
            media: function () {
                var features;
                var rules;
                var media;
                var debugInfo;
                var index = parserInput.i;
                if (context.dumpLineNumbers) {
                    debugInfo = getDebugInfo(index);
                }
                parserInput.save();
                if (parserInput.$str('@media')) {
                    features = this.mediaFeatures();
                    rules = this.block();
                    if (!rules) {
                        error('media definitions require block statements after any features');
                    }
                    parserInput.forget();
                    media = new (tree_1.default.Media)(rules, features, index, fileInfo);
                    if (context.dumpLineNumbers) {
                        media.debugInfo = debugInfo;
                    }
                    return media;
                }
                parserInput.restore();
            },
            //
            // A @plugin directive, used to import plugins dynamically.
            //
            //     @plugin (args) "lib";
            //
            plugin: function () {
                var path;
                var args;
                var options;
                var index = parserInput.i;
                var dir = parserInput.$re(/^@plugin?\s+/);
                if (dir) {
                    args = this.pluginArgs();
                    if (args) {
                        options = {
                            pluginArgs: args,
                            isPlugin: true
                        };
                    }
                    else {
                        options = { isPlugin: true };
                    }
                    if ((path = this.entities.quoted() || this.entities.url())) {
                        if (!parserInput.$char(';')) {
                            parserInput.i = index;
                            error('missing semi-colon on @plugin');
                        }
                        return new (tree_1.default.Import)(path, null, options, index, fileInfo);
                    }
                    else {
                        parserInput.i = index;
                        error('malformed @plugin statement');
                    }
                }
            },
            pluginArgs: function () {
                // list of options, surrounded by parens
                parserInput.save();
                if (!parserInput.$char('(')) {
                    parserInput.restore();
                    return null;
                }
                var args = parserInput.$re(/^\s*([^\);]+)\)\s*/);
                if (args[1]) {
                    parserInput.forget();
                    return args[1].trim();
                }
                else {
                    parserInput.restore();
                    return null;
                }
            },
            //
            // A CSS AtRule
            //
            //     @charset "utf-8";
            //
            atrule: function () {
                var index = parserInput.i;
                var name;
                var value;
                var rules;
                var nonVendorSpecificName;
                var hasIdentifier;
                var hasExpression;
                var hasUnknown;
                var hasBlock = true;
                var isRooted = true;
                if (parserInput.currentChar() !== '@') {
                    return;
                }
                value = this['import']() || this.plugin() || this.media();
                if (value) {
                    return value;
                }
                parserInput.save();
                name = parserInput.$re(/^@[a-z-]+/);
                if (!name) {
                    return;
                }
                nonVendorSpecificName = name;
                if (name.charAt(1) == '-' &amp;&amp; name.indexOf('-', 2) > 0) {
                    nonVendorSpecificName = "@" + name.slice(name.indexOf('-', 2) + 1);
                }
                switch (nonVendorSpecificName) {
                    case '@charset':
                        hasIdentifier = true;
                        hasBlock = false;
                        break;
                    case '@namespace':
                        hasExpression = true;
                        hasBlock = false;
                        break;
                    case '@keyframes':
                    case '@counter-style':
                        hasIdentifier = true;
                        break;
                    case '@document':
                    case '@supports':
                        hasUnknown = true;
                        isRooted = false;
                        break;
                    default:
                        hasUnknown = true;
                        break;
                }
                parserInput.commentStore.length = 0;
                if (hasIdentifier) {
                    value = this.entity();
                    if (!value) {
                        error("expected " + name + " identifier");
                    }
                }
                else if (hasExpression) {
                    value = this.expression();
                    if (!value) {
                        error("expected " + name + " expression");
                    }
                }
                else if (hasUnknown) {
                    value = this.permissiveValue(/^[{;]/);
                    hasBlock = (parserInput.currentChar() === '{');
                    if (!value) {
                        if (!hasBlock &amp;&amp; parserInput.currentChar() !== ';') {
                            error(name + " rule is missing block or ending semi-colon");
                        }
                    }
                    else if (!value.value) {
                        value = null;
                    }
                }
                if (hasBlock) {
                    rules = this.blockRuleset();
                }
                if (rules || (!hasBlock &amp;&amp; value &amp;&amp; parserInput.$char(';'))) {
                    parserInput.forget();
                    return new (tree_1.default.AtRule)(name, value, rules, index, fileInfo, context.dumpLineNumbers ? getDebugInfo(index) : null, isRooted);
                }
                parserInput.restore('at-rule options not recognised');
            },
            //
            // A Value is a comma-delimited list of Expressions
            //
            //     font-family: Baskerville, Georgia, serif;
            //
            // In a Rule, a Value represents everything after the `:`,
            // and before the `;`.
            //
            value: function () {
                var e;
                var expressions = [];
                var index = parserInput.i;
                do {
                    e = this.expression();
                    if (e) {
                        expressions.push(e);
                        if (!parserInput.$char(',')) {
                            break;
                        }
                    }
                } while (e);
                if (expressions.length > 0) {
                    return new (tree_1.default.Value)(expressions, index);
                }
            },
            important: function () {
                if (parserInput.currentChar() === '!') {
                    return parserInput.$re(/^! *important/);
                }
            },
            sub: function () {
                var a;
                var e;
                parserInput.save();
                if (parserInput.$char('(')) {
                    a = this.addition();
                    if (a &amp;&amp; parserInput.$char(')')) {
                        parserInput.forget();
                        e = new (tree_1.default.Expression)([a]);
                        e.parens = true;
                        return e;
                    }
                    parserInput.restore('Expected \')\'');
                    return;
                }
                parserInput.restore();
            },
            multiplication: function () {
                var m;
                var a;
                var op;
                var operation;
                var isSpaced;
                m = this.operand();
                if (m) {
                    isSpaced = parserInput.isWhitespace(-1);
                    while (true) {
                        if (parserInput.peek(/^\/[*\/]/)) {
                            break;
                        }
                        parserInput.save();
                        op = parserInput.$char('/') || parserInput.$char('*') || parserInput.$str('./');
                        if (!op) {
                            parserInput.forget();
                            break;
                        }
                        a = this.operand();
                        if (!a) {
                            parserInput.restore();
                            break;
                        }
                        parserInput.forget();
                        m.parensInOp = true;
                        a.parensInOp = true;
                        operation = new (tree_1.default.Operation)(op, [operation || m, a], isSpaced);
                        isSpaced = parserInput.isWhitespace(-1);
                    }
                    return operation || m;
                }
            },
            addition: function () {
                var m;
                var a;
                var op;
                var operation;
                var isSpaced;
                m = this.multiplication();
                if (m) {
                    isSpaced = parserInput.isWhitespace(-1);
                    while (true) {
                        op = parserInput.$re(/^[-+]\s+/) || (!isSpaced &amp;&amp; (parserInput.$char('+') || parserInput.$char('-')));
                        if (!op) {
                            break;
                        }
                        a = this.multiplication();
                        if (!a) {
                            break;
                        }
                        m.parensInOp = true;
                        a.parensInOp = true;
                        operation = new (tree_1.default.Operation)(op, [operation || m, a], isSpaced);
                        isSpaced = parserInput.isWhitespace(-1);
                    }
                    return operation || m;
                }
            },
            conditions: function () {
                var a;
                var b;
                var index = parserInput.i;
                var condition;
                a = this.condition(true);
                if (a) {
                    while (true) {
                        if (!parserInput.peek(/^,\s*(not\s*)?\(/) || !parserInput.$char(',')) {
                            break;
                        }
                        b = this.condition(true);
                        if (!b) {
                            break;
                        }
                        condition = new (tree_1.default.Condition)('or', condition || a, b, index);
                    }
                    return condition || a;
                }
            },
            condition: function (needsParens) {
                var result;
                var logical;
                var next;
                function or() {
                    return parserInput.$str('or');
                }
                result = this.conditionAnd(needsParens);
                if (!result) {
                    return;
                }
                logical = or();
                if (logical) {
                    next = this.condition(needsParens);
                    if (next) {
                        result = new (tree_1.default.Condition)(logical, result, next);
                    }
                    else {
                        return;
                    }
                }
                return result;
            },
            conditionAnd: function (needsParens) {
                var result;
                var logical;
                var next;
                var self = this;
                function insideCondition() {
                    var cond = self.negatedCondition(needsParens) || self.parenthesisCondition(needsParens);
                    if (!cond &amp;&amp; !needsParens) {
                        return self.atomicCondition(needsParens);
                    }
                    return cond;
                }
                function and() {
                    return parserInput.$str('and');
                }
                result = insideCondition();
                if (!result) {
                    return;
                }
                logical = and();
                if (logical) {
                    next = this.conditionAnd(needsParens);
                    if (next) {
                        result = new (tree_1.default.Condition)(logical, result, next);
                    }
                    else {
                        return;
                    }
                }
                return result;
            },
            negatedCondition: function (needsParens) {
                if (parserInput.$str('not')) {
                    var result = this.parenthesisCondition(needsParens);
                    if (result) {
                        result.negate = !result.negate;
                    }
                    return result;
                }
            },
            parenthesisCondition: function (needsParens) {
                function tryConditionFollowedByParenthesis(me) {
                    var body;
                    parserInput.save();
                    body = me.condition(needsParens);
                    if (!body) {
                        parserInput.restore();
                        return;
                    }
                    if (!parserInput.$char(')')) {
                        parserInput.restore();
                        return;
                    }
                    parserInput.forget();
                    return body;
                }
                var body;
                parserInput.save();
                if (!parserInput.$str('(')) {
                    parserInput.restore();
                    return;
                }
                body = tryConditionFollowedByParenthesis(this);
                if (body) {
                    parserInput.forget();
                    return body;
                }
                body = this.atomicCondition(needsParens);
                if (!body) {
                    parserInput.restore();
                    return;
                }
                if (!parserInput.$char(')')) {
                    parserInput.restore("expected ')' got '" + parserInput.currentChar() + "'");
                    return;
                }
                parserInput.forget();
                return body;
            },
            atomicCondition: function (needsParens) {
                var entities = this.entities;
                var index = parserInput.i;
                var a;
                var b;
                var c;
                var op;
                function cond() {
                    return this.addition() || entities.keyword() || entities.quoted() || entities.mixinLookup();
                }
                cond = cond.bind(this);
                a = cond();
                if (a) {
                    if (parserInput.$char('>')) {
                        if (parserInput.$char('=')) {
                            op = '>=';
                        }
                        else {
                            op = '>';
                        }
                    }
                    else if (parserInput.$char('&lt;')) {
                        if (parserInput.$char('=')) {
                            op = '&lt;=';
                        }
                        else {
                            op = '&lt;';
                        }
                    }
                    else if (parserInput.$char('=')) {
                        if (parserInput.$char('>')) {
                            op = '=>';
                        }
                        else if (parserInput.$char('&lt;')) {
                            op = '=&lt;';
                        }
                        else {
                            op = '=';
                        }
                    }
                    if (op) {
                        b = cond();
                        if (b) {
                            c = new (tree_1.default.Condition)(op, a, b, index, false);
                        }
                        else {
                            error('expected expression');
                        }
                    }
                    else {
                        c = new (tree_1.default.Condition)('=', a, new (tree_1.default.Keyword)('true'), index, false);
                    }
                    return c;
                }
            },
            //
            // An operand is anything that can be part of an operation,
            // such as a Color, or a Variable
            //
            operand: function () {
                var entities = this.entities;
                var negate;
                if (parserInput.peek(/^-[@\$\(]/)) {
                    negate = parserInput.$char('-');
                }
                var o = this.sub() || entities.dimension() ||
                    entities.color() || entities.variable() ||
                    entities.property() || entities.call() ||
                    entities.quoted(true) || entities.colorKeyword() ||
                    entities.mixinLookup();
                if (negate) {
                    o.parensInOp = true;
                    o = new (tree_1.default.Negative)(o);
                }
                return o;
            },
            //
            // Expressions either represent mathematical operations,
            // or white-space delimited Entities.
            //
            //     1px solid black
            //     @var * 2
            //
            expression: function () {
                var entities = [];
                var e;
                var delim;
                var index = parserInput.i;
                do {
                    e = this.comment();
                    if (e) {
                        entities.push(e);
                        continue;
                    }
                    e = this.addition() || this.entity();
                    if (e instanceof tree_1.default.Comment) {
                        e = null;
                    }
                    if (e) {
                        entities.push(e);
                        // operations do not allow keyword "/" dimension (e.g. small/20px) so we support that here
                        if (!parserInput.peek(/^\/[\/*]/)) {
                            delim = parserInput.$char('/');
                            if (delim) {
                                entities.push(new (tree_1.default.Anonymous)(delim, index));
                            }
                        }
                    }
                } while (e);
                if (entities.length > 0) {
                    return new (tree_1.default.Expression)(entities);
                }
            },
            property: function () {
                var name = parserInput.$re(/^(\*?-?[_a-zA-Z0-9-]+)\s*:/);
                if (name) {
                    return name[1];
                }
            },
            ruleProperty: function () {
                var name = [];
                var index = [];
                var s;
                var k;
                parserInput.save();
                var simpleProperty = parserInput.$re(/^([_a-zA-Z0-9-]+)\s*:/);
                if (simpleProperty) {
                    name = [new (tree_1.default.Keyword)(simpleProperty[1])];
                    parserInput.forget();
                    return name;
                }
                function match(re) {
                    var i = parserInput.i;
                    var chunk = parserInput.$re(re);
                    if (chunk) {
                        index.push(i);
                        return name.push(chunk[1]);
                    }
                }
                match(/^(\*?)/);
                while (true) {
                    if (!match(/^((?:[\w-]+)|(?:[@\$]\{[\w-]+\}))/)) {
                        break;
                    }
                }
                if ((name.length > 1) &amp;&amp; match(/^((?:\+_|\+)?)\s*:/)) {
                    parserInput.forget();
                    // at last, we have the complete match now. move forward,
                    // convert name particles to tree objects and return:
                    if (name[0] === '') {
                        name.shift();
                        index.shift();
                    }
                    for (k = 0; k &lt; name.length; k++) {
                        s = name[k];
                        name[k] = (s.charAt(0) !== '@' &amp;&amp; s.charAt(0) !== '$') ?
                            new (tree_1.default.Keyword)(s) :
                            (s.charAt(0) === '@' ?
                                new (tree_1.default.Variable)("@" + s.slice(2, -1), index[k], fileInfo) :
                                new (tree_1.default.Property)("$" + s.slice(2, -1), index[k], fileInfo));
                    }
                    return name;
                }
                parserInput.restore();
            }
        }
    };
};
Parser.serializeVars = function (vars) {
    var s = '';
    for (var name_1 in vars) {
        if (Object.hasOwnProperty.call(vars, name_1)) {
            var value = vars[name_1];
            s += ((name_1[0] === '@') ? '' : '@') + name_1 + ": " + value + ((String(value).slice(-1) === ';') ? '' : ';');
        }
    }
    return s;
};
exports.default = Parser;
//# sourceMappingURL=parser.js.map</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-ColorConverter.html">ColorConverter</a></li><li><a href="module-ContextMenu.html">ContextMenu</a></li><li><a href="module-DiscordAPI.html">DiscordAPI</a></li><li><a href="module-DiscordClasses.html">DiscordClasses</a></li><li><a href="module-DiscordClassModules.html">DiscordClassModules</a></li><li><a href="module-DiscordContextMenu.html">DiscordContextMenu</a></li><li><a href="module-DiscordModules.html">DiscordModules</a></li><li><a href="module-DiscordSelectors.html">DiscordSelectors</a></li><li><a href="module-DOMTools.html">DOMTools</a></li><li><a href="module-Logger.html">Logger</a></li><li><a href="module-Modals.html">Modals</a></li><li><a href="module-Patcher.html">Patcher</a></li><li><a href="module-PluginUpdater.html">PluginUpdater</a></li><li><a href="module-PluginUtilities.html">PluginUtilities</a></li><li><a href="module-Popouts.html">Popouts</a></li><li><a href="module-powercord_injector.html">powercord/injector</a></li><li><a href="module-ReactComponents.html">ReactComponents</a></li><li><a href="module-ReactTools.html">ReactTools</a></li><li><a href="module-Settings.html">Settings</a></li><li><a href="module-Toasts.html">Toasts</a></li><li><a href="module-Tooltip.html">Tooltip</a></li><li><a href="module-Utilities.html">Utilities</a></li><li><a href="module-WebpackModules.html">WebpackModules</a></li></ul><h3>Classes</h3><ul><li><a href="global.html#ArraySet">ArraySet</a></li><li><a href="global.html#BasicSourceMapConsumer">BasicSourceMapConsumer</a></li><li><a href="CJSImportProcessor.html">CJSImportProcessor</a></li><li><a href="CJSImportTransformer.html">CJSImportTransformer</a></li><li><a href="CommanderError.html">CommanderError</a></li><li><a href="CommandsAPI.html">CommandsAPI</a></li><li><a href="global.html#Compiler">Compiler</a></li><li><a href="CompressedObject.html">CompressedObject</a></li><li><a href="ConvertWorker.html">ConvertWorker</a></li><li><a href="Crc32Probe.html">Crc32Probe</a></li><li><a href="CSS.html">CSS</a></li><li><a href="DataLengthProbe.html">DataLengthProbe</a></li><li><a href="DataWorker.html">DataWorker</a></li><li><a href="DirEntry.html">DirEntry</a></li><li><a href="ESMImportTransformer.html">ESMImportTransformer</a></li><li><a href="FlateWorker.html">FlateWorker</a></li><li><a href="FSWatcher.html">FSWatcher</a></li><li><a href="GenericWorker.html">GenericWorker</a></li><li><a href="global.html#IndexedSourceMapConsumer">IndexedSourceMapConsumer</a></li><li><a href="JSX.html">JSX</a></li><li><a href="JSZip.html">JSZip</a></li><li><a href="KeybindsAPI.html">KeybindsAPI</a></li><li><a href="LabsAPI.html">LabsAPI</a></li><li><a href="Less.html">Less</a></li><li><a href="LessError.html">LessError</a></li><li><a href="global.html#MappingList">MappingList</a></li><li><a href="module.html#.exports">exports</a></li><li><a href="module-ContextMenu-ImageItem.html">ImageItem</a></li><li><a href="module-ContextMenu-ItemGroup.html">ItemGroup</a></li><li><a href="module-ContextMenu-Menu.html">Menu</a></li><li><a href="module-ContextMenu-MenuItem.html">MenuItem</a></li><li><a href="module-ContextMenu-SubMenuItem.html">SubMenuItem</a></li><li><a href="module-ContextMenu-TextItem.html">TextItem</a></li><li><a href="module-ContextMenu-ToggleItem.html">ToggleItem</a></li><li><a href="module-DiscordAPI.Channel.html">Channel</a></li><li><a href="module-DiscordAPI.Guild.html">Guild</a></li><li><a href="module-DiscordAPI.InsufficientPermissions.html">InsufficientPermissions</a></li><li><a href="module-DiscordAPI.Message.html">Message</a></li><li><a href="module-DiscordAPI.User.html">User</a></li><li><a href="module-DiscordAPI.UserSettings.html">UserSettings</a></li><li><a href="module-DOMTools.ClassName.html">ClassName</a></li><li><a href="module-DOMTools.DOMObserver.html">DOMObserver</a></li><li><a href="module-DOMTools.Selector.html">Selector</a></li><li><a href="module-PluginUtilities-Helpers.html">Helpers</a></li><li><a href="module-ReactTools-Reflection.html">Reflection</a></li><li><a href="module-Settings.ColorPicker.html">ColorPicker</a></li><li><a href="module-Settings.Dropdown.html">Dropdown</a></li><li><a href="module-Settings.FilePicker.html">FilePicker</a></li><li><a href="module-Settings.Keybind.html">Keybind</a></li><li><a href="module-Settings.RadioGroup.html">RadioGroup</a></li><li><a href="module-Settings.SettingField.html">SettingField</a></li><li><a href="module-Settings.SettingGroup.html">SettingGroup</a></li><li><a href="module-Settings.SettingPanel.html">SettingPanel</a></li><li><a href="module-Settings.Slider.html">Slider</a></li><li><a href="module-Settings.Switch.html">Switch</a></li><li><a href="module-Settings.Textbox.html">Textbox</a></li><li><a href="module-Tooltip-Tooltip.html">Tooltip</a></li><li><a href="module-WebpackModules-Filters.html">Filters</a></li><li><a href="module-WebpackModules-List.html">List</a></li><li><a href="module-WebpackModules-Listenable.html">Listenable</a></li><li><a href="module-WebpackModules-Screen.html">Screen</a></li><li><a href="NodejsStreamInputAdapter.html">NodejsStreamInputAdapter</a></li><li><a href="NodejsStreamOutputAdapter.html">NodejsStreamOutputAdapter</a></li><li><a href="OptionalChainingNullishTransformer.html">OptionalChainingNullishTransformer</a></li><li><a href="Plugin.html">Plugin</a></li><li><a href="Powercord.html">Powercord</a></li><li><a href="ReactDisplayNameTransformer.html">ReactDisplayNameTransformer</a></li><li><a href="RouterAPI.html">RouterAPI</a></li><li><a href="RpcAPI.html">RpcAPI</a></li><li><a href="SCSS.html">SCSS</a></li><li><a href="Section.html">Section</a></li><li><a href="SettingsAPI.html">SettingsAPI</a></li><li><a href="global.html#SourceMapGenerator">SourceMapGenerator</a></li><li><a href="global.html#SourceNode">SourceNode</a></li><li><a href="StreamHelper.html">StreamHelper</a></li><li><a href="Stylus.html">Stylus</a></li><li><a href="Updatable.html">Updatable</a></li><li><a href="Utf8DecodeWorker.html">Utf8DecodeWorker</a></li><li><a href="Utf8EncodeWorker.html">Utf8EncodeWorker</a></li><li><a href="ZipEntries.html">ZipEntries</a></li><li><a href="ZipEntry.html">ZipEntry</a></li><li><a href="ZipObject.html">ZipObject</a></li></ul><h3>Interfaces</h3><ul><li><a href="module-DiscordContextMenu-MenuControlItem.html">MenuControlItem</a></li><li><a href="module-DiscordContextMenu-MenuItem.html">MenuItem</a></li><li><a href="module-DiscordContextMenu-MenuRadioItem.html">MenuRadioItem</a></li><li><a href="module-DiscordContextMenu-MenuToggleItem.html">MenuToggleItem</a></li><li><a href="module-DiscordContextMenu-SubMenuItem.html">SubMenuItem</a></li><li><a href="module-DOMTools-Offset.html">Offset</a></li><li><a href="module-FilePicker.html">FilePicker</a></li><li><a href="module-Modals-Changelog.html">Changelog</a></li><li><a href="module-Settings-DropdownItem.html">DropdownItem</a></li><li><a href="module-Settings-RadioItem.html">RadioItem</a></li></ul><h3>Mixins</h3><ul><li><a href="FsEventsHandler.html">FsEventsHandler</a></li><li><a href="NodeFsHandler.html">NodeFsHandler</a></li></ul><h3>Global</h3><ul><li><a href="global.html"></a></li><li><a href="global.html#__extends">__extends</a></li><li><a href="global.html#__importDefault">__importDefault</a></li><li><a href="global.html#_init">_init</a></li><li><a href="global.html#_tsinterfacechecker">_tsinterfacechecker</a></li><li><a href="global.html#_utf8len">_utf8len</a></li><li><a href="global.html#absolute">absolute</a></li><li><a href="global.html#accumulate">accumulate</a></li><li><a href="global.html#addFile">addFile</a></li><li><a href="global.html#addHook">addHook</a></li><li><a href="global.html#addParent">addParent</a></li><li><a href="global.html#adjust">adjust</a></li><li><a href="global.html#alias">alias</a></li><li><a href="global.html#alpha">alpha</a></li><li><a href="global.html#AnsiEscapes">AnsiEscapes</a></li><li><a href="global.html#anymatch">anymatch</a></li><li><a href="global.html#applySourceMaps">applySourceMaps</a></li><li><a href="global.html#Arguments">Arguments</a></li><li><a href="global.html#array">array</a></li><li><a href="global.html#arrayLikeToArrayLike">arrayLikeToArrayLike</a></li><li><a href="global.html#arrayLikeToString">arrayLikeToString</a></li><li><a href="global.html#arrayToStringHelper">arrayToStringHelper</a></li><li><a href="global.html#assertColor">assertColor</a></li><li><a href="global.html#assertPresent">assertPresent</a></li><li><a href="global.html#assertString">assertString</a></li><li><a href="global.html#assertType">assertType</a></li><li><a href="global.html#Atblock">Atblock</a></li><li><a href="global.html#Atrule">Atrule</a></li><li><a href="global.html#Base">Base</a></li><li><a href="global.html#basename">basename</a></li><li><a href="global.html#baseParseSubscript">baseParseSubscript</a></li><li><a href="global.html#BasicType">BasicType</a></li><li><a href="global.html#basicTypes">basicTypes</a></li><li><a href="global.html#BinOp">BinOp</a></li><li><a href="global.html#blend">blend</a></li><li><a href="global.html#Block">Block</a></li><li><a href="global.html#blue">blue</a></li><li><a href="global.html#Boolean">Boolean</a></li><li><a href="global.html#braces">braces</a></li><li><a href="global.html#Call">Call</a></li><li><a href="global.html#camelcase">camelcase</a></li><li><a href="global.html#catch">catch</a></li><li><a href="global.html#charset">charset</a></li><li><a href="global.html#Charset">Charset</a></li><li><a href="global.html#checkEntryCRC32">checkEntryCRC32</a></li><li><a href="global.html#Checker">Checker</a></li><li><a href="global.html#checkImports">checkImports</a></li><li><a href="global.html#checkSupport">checkSupport</a></li><li><a href="global.html#clamp">clamp</a></li><li><a href="global.html#clampAlpha">clampAlpha</a></li><li><a href="global.html#clampDegrees">clampDegrees</a></li><li><a href="global.html#clampPercentage">clampPercentage</a></li><li><a href="global.html#coerce">coerce</a></li><li><a href="global.html#coerceArray">coerceArray</a></li><li><a href="global.html#coerceObject">coerceObject</a></li><li><a href="global.html#CoercionError">CoercionError</a></li><li><a href="global.html#colors">colors</a></li><li><a href="global.html#Command">Command</a></li><li><a href="global.html#comment">comment</a></li><li><a href="global.html#Comment">Comment</a></li><li><a href="global.html#compare">compare</a></li><li><a href="global.html#compareByGeneratedPositionsDeflated">compareByGeneratedPositionsDeflated</a></li><li><a href="global.html#compareByGeneratedPositionsInflated">compareByGeneratedPositionsInflated</a></li><li><a href="global.html#compareByOriginalPositions">compareByOriginalPositions</a></li><li><a href="global.html#compile">compile</a></li><li><a href="global.html#compileSelectors">compileSelectors</a></li><li><a href="global.html#component">component</a></li><li><a href="global.html#componentMap">componentMap</a></li><li><a href="global.html#Compressed">Compressed</a></li><li><a href="global.html#computeSourceMap">computeSourceMap</a></li><li><a href="global.html#computeSourceURL">computeSourceURL</a></li><li><a href="global.html#concat">concat</a></li><li><a href="global.html#config">config</a></li><li><a href="global.html#contentType">contentType</a></li><li><a href="global.html#contrast">contrast</a></li><li><a href="global.html#convert">convert</a></li><li><a href="global.html#convertCSS">convertCSS</a></li><li><a href="global.html#Converter">Converter</a></li><li><a href="global.html#copy">copy</a></li><li><a href="global.html#coremods">coremods</a></li><li><a href="global.html#crc32str">crc32str</a></li><li><a href="global.html#createCheckers">createCheckers</a></li><li><a href="global.html#createDebug">createDebug</a></li><li><a href="global.html#createFSEventsInstance">createFSEventsInstance</a></li><li><a href="global.html#createFsWatchInstance">createFsWatchInstance</a></li><li><a href="global.html#createPattern">createPattern</a></li><li><a href="global.html#crypto">crypto</a></li><li><a href="global.html#decode">decode</a></li><li><a href="global.html#defaultMimes">defaultMimes</a></li><li><a href="global.html#define">define</a></li><li><a href="global.html#deflate">deflate</a></li><li><a href="global.html#Deflate">Deflate</a></li><li><a href="global.html#deflateRaw">deflateRaw</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#deprecate">deprecate</a></li><li><a href="global.html#DepsResolver">DepsResolver</a></li><li><a href="global.html#DetailContext">DetailContext</a></li><li><a href="global.html#dirname">dirname</a></li><li><a href="global.html#disable">disable</a></li><li><a href="global.html#disableAll">disableAll</a></li><li><a href="global.html#doQuickSort">doQuickSort</a></li><li><a href="global.html#DOT_LITERAL">DOT_LITERAL</a></li><li><a href="global.html#Each">Each</a></li><li><a href="global.html#emit">emit</a></li><li><a href="global.html#enable">enable</a></li><li><a href="global.html#enableAll">enableAll</a></li><li><a href="global.html#enabled">enabled</a></li><li><a href="global.html#encloseBrace">encloseBrace</a></li><li><a href="global.html#encode">encode</a></li><li><a href="global.html#encodingTypes">encodingTypes</a></li><li><a href="global.html#enumlit">enumlit</a></li><li><a href="global.html#enumtype">enumtype</a></li><li><a href="global.html#error">error</a></li><li><a href="global.html#escapeNode">escapeNode</a></li><li><a href="global.html#Evaluator">Evaluator</a></li><li><a href="global.html#EventEmitter">EventEmitter</a></li><li><a href="global.html#events">events</a></li><li><a href="global.html#exceedsLimit">exceedsLimit</a></li><li><a href="global.html#expandRange">expandRange</a></li><li><a href="global.html#Expression">Expression</a></li><li><a href="global.html#Extend">Extend</a></li><li><a href="global.html#extension">extension</a></li><li><a href="global.html#extname">extname</a></li><li><a href="global.html#FACTOR_TABLE">FACTOR_TABLE</a></li><li><a href="global.html#Feature">Feature</a></li><li><a href="global.html#find">find</a></li><li><a href="global.html#findCompression">findCompression</a></li><li><a href="global.html#flatten">flatten</a></li><li><a href="global.html#fmtLong">fmtLong</a></li><li><a href="global.html#fmtShort">fmtShort</a></li><li><a href="global.html#formatArgs">formatArgs</a></li><li><a href="global.html#formatException">formatException</a></li><li><a href="global.html#formatJSXStringValueLiteral">formatJSXStringValueLiteral</a></li><li><a href="global.html#formatJSXTextLiteral">formatJSXTextLiteral</a></li><li><a href="global.html#formatJSXTextReplacement">formatJSXTextReplacement</a></li><li><a href="global.html#formatters">formatters</a></li><li><a href="global.html#Frame">Frame</a></li><li><a href="global.html#fromHSLA">fromHSLA</a></li><li><a href="global.html#fromRGBA">fromRGBA</a></li><li><a href="global.html#fromVLQSigned">fromVLQSigned</a></li><li><a href="global.html#fs">fs</a></li><li><a href="global.html#FSEventsWatchers">FSEventsWatchers</a></li><li><a href="global.html#fsWatchBroadcast">fsWatchBroadcast</a></li><li><a href="global.html#FsWatchInstances">FsWatchInstances</a></li><li><a href="global.html#func">func</a></li><li><a href="global.html#Function">Function</a></li><li><a href="global.html#functions">functions</a></li><li><a href="global.html#generateCentralDirectoryEnd">generateCentralDirectoryEnd</a></li><li><a href="global.html#generateDataDescriptors">generateDataDescriptors</a></li><li><a href="global.html#generateDosExternalFileAttr">generateDosExternalFileAttr</a></li><li><a href="global.html#generatedPositionAfter">generatedPositionAfter</a></li><li><a href="global.html#generateUnixExternalFileAttr">generateUnixExternalFileAttr</a></li><li><a href="global.html#generateWorker">generateWorker</a></li><li><a href="global.html#generateZipParts">generateZipParts</a></li><li><a href="global.html#genIterator">genIterator</a></li><li><a href="global.html#get">get</a></li><li><a href="global.html#getAppDir">getAppDir</a></li><li><a href="global.html#getArg">getArg</a></li><li><a href="global.html#getCache">getCache</a></li><li><a href="global.html#getClassInfo">getClassInfo</a></li><li><a href="global.html#getCompression">getCompression</a></li><li><a href="global.html#getDeclarationInfo">getDeclarationInfo</a></li><li><a href="global.html#getFormattedTokens">getFormattedTokens</a></li><li><a href="global.html#getIdentifierNames">getIdentifierNames</a></li><li><a href="global.html#getSucraseContext">getSucraseContext</a></li><li><a href="global.html#getTSImportedNames">getTSImportedNames</a></li><li><a href="global.html#getType">getType</a></li><li><a href="global.html#getTypeOf">getTypeOf</a></li><li><a href="global.html#green">green</a></li><li><a href="global.html#Group">Group</a></li><li><a href="global.html#gzip">gzip</a></li><li><a href="global.html#hasOwnProperty">hasOwnProperty</a></li><li><a href="global.html#hasShadowedGlobals">hasShadowedGlobals</a></li><li><a href="global.html#hsl">hsl</a></li><li><a href="global.html#hsla">hsla</a></li><li><a href="global.html#HSLA">HSLA</a></li><li><a href="global.html#hue">hue</a></li><li><a href="global.html#humanReadableArgName">humanReadableArgName</a></li><li><a href="global.html#Ident">Ident</a></li><li><a href="global.html#identifyShadowedGlobals">identifyShadowedGlobals</a></li><li><a href="global.html#identity">identity</a></li><li><a href="global.html#If">If</a></li><li><a href="global.html#iface">iface</a></li><li><a href="global.html#Image">Image</a></li><li><a href="global.html#imageSize">imageSize</a></li><li><a href="global.html#Import">Import</a></li><li><a href="global.html#importFile">importFile</a></li><li><a href="global.html#imports">imports</a></li><li><a href="global.html#incrementNodeInspectorPort">incrementNodeInspectorPort</a></li><li><a href="global.html#Inflate">Inflate</a></li><li><a href="global.html#inflate">inflate</a></li><li><a href="global.html#inflateRaw">inflateRaw</a></li><li><a href="global.html#inherits">inherits</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#inspect">inspect</a></li><li><a href="global.html#inspectOpts">inspectOpts</a></li><li><a href="global.html#instances">instances</a></li><li><a href="global.html#intersection">intersection</a></li><li><a href="global.html#isAccessModifier">isAccessModifier</a></li><li><a href="global.html#isAnyObject">isAnyObject</a></li><li><a href="global.html#isArray">isArray</a></li><li><a href="global.html#isAsyncOperation">isAsyncOperation</a></li><li><a href="global.html#isBlob">isBlob</a></li><li><a href="global.html#isBoolean">isBoolean</a></li><li><a href="global.html#isDate">isDate</a></li><li><a href="global.html#isEmptyArray">isEmptyArray</a></li><li><a href="global.html#isEmptyObject">isEmptyObject</a></li><li><a href="global.html#isEmptyString">isEmptyString</a></li><li><a href="global.html#isError">isError</a></li><li><a href="global.html#isFile">isFile</a></li><li><a href="global.html#isFullArray">isFullArray</a></li><li><a href="global.html#isFullObject">isFullObject</a></li><li><a href="global.html#isFullString">isFullString</a></li><li><a href="global.html#isFunction">isFunction</a></li><li><a href="global.html#isInvalidBrace">isInvalidBrace</a></li><li><a href="global.html#isMap">isMap</a></li><li><a href="global.html#isNaNValue">isNaNValue</a></li><li><a href="global.html#isNull">isNull</a></li><li><a href="global.html#isNullOrUndefined">isNullOrUndefined</a></li><li><a href="global.html#isNumber">isNumber</a></li><li><a href="global.html#isObject">isObject</a></li><li><a href="global.html#isObjectLike">isObjectLike</a></li><li><a href="global.html#isOpenOrClose">isOpenOrClose</a></li><li><a href="global.html#isPlainObject">isPlainObject</a></li><li><a href="global.html#isPrimitive">isPrimitive</a></li><li><a href="global.html#isPromise">isPromise</a></li><li><a href="global.html#isRegExp">isRegExp</a></li><li><a href="global.html#isRegistered">isRegistered</a></li><li><a href="global.html#isSet">isSet</a></li><li><a href="global.html#isString">isString</a></li><li><a href="global.html#isSymbol">isSymbol</a></li><li><a href="global.html#isType">isType</a></li><li><a href="global.html#isUndefined">isUndefined</a></li><li><a href="global.html#isWeakMap">isWeakMap</a></li><li><a href="global.html#isWeakSet">isWeakSet</a></li><li><a href="global.html#join">join</a></li><li><a href="global.html#json">json</a></li><li><a href="global.html#jsonCharacterEncoding">jsonCharacterEncoding</a></li><li><a href="global.html#jsonMimeTypeRegex">jsonMimeTypeRegex</a></li><li><a href="global.html#Keyframes">Keyframes</a></li><li><a href="global.html#lessFolder">lessFolder</a></li><li><a href="global.html#Lexer">Lexer</a></li><li><a href="global.html#lightness">lightness</a></li><li><a href="global.html#lit">lit</a></li><li><a href="global.html#Literal">Literal</a></li><li><a href="global.html#literal">literal</a></li><li><a href="global.html#load">load</a></li><li><a href="global.html#loadImplementation">loadImplementation</a></li><li><a href="global.html#localstorage">localstorage</a></li><li><a href="global.html#log">log</a></li><li><a href="global.html#lookup">lookup</a></li><li><a href="global.html#lookupIndex">lookupIndex</a></li><li><a href="global.html#lruMemoize">lruMemoize</a></li><li><a href="global.html#luminosity">luminosity</a></li><li><a href="global.html#makeTable">makeTable</a></li><li><a href="global.html#Mapping">Mapping</a></li><li><a href="global.html#match">match</a></li><li><a href="global.html#matchPatterns">matchPatterns</a></li><li><a href="global.html#math">math</a></li><li><a href="global.html#Media">Media</a></li><li><a href="global.html#Member">Member</a></li><li><a href="global.html#merge">merge</a></li><li><a href="global.html#middleware">middleware</a></li><li><a href="global.html#mime">mime</a></li><li><a href="global.html#mixin">mixin</a></li><li><a href="global.html#Module">Module</a></li><li><a href="global.html#modules">modules</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#names">names</a></li><li><a href="global.html#Namespace">Namespace</a></li><li><a href="global.html#newBlob">newBlob</a></li><li><a href="global.html#next">next</a></li><li><a href="global.html#Node">Node</a></li><li><a href="global.html#nodes">nodes</a></li><li><a href="global.html#NoopContext">NoopContext</a></li><li><a href="global.html#normalize">normalize</a></li><li><a href="global.html#Normalizer">Normalizer</a></li><li><a href="global.html#Null">Null</a></li><li><a href="global.html#NullCache">NullCache</a></li><li><a href="global.html#Object">Object</a></li><li><a href="global.html#Observable">Observable</a></li><li><a href="global.html#oldJson">oldJson</a></li><li><a href="global.html#operate">operate</a></li><li><a href="global.html#opt">opt</a></li><li><a href="global.html#Option">Option</a></li><li><a href="global.html#optionalWrap">optionalWrap</a></li><li><a href="global.html#outputHelpIfRequested">outputHelpIfRequested</a></li><li><a href="global.html#pad">pad</a></li><li><a href="global.html#param">param</a></li><li><a href="global.html#Params">Params</a></li><li><a href="global.html#params">params</a></li><li><a href="global.html#parse">parse</a></li><li><a href="global.html#ParseError">ParseError</a></li><li><a href="global.html#parseIdentifierStatement">parseIdentifierStatement</a></li><li><a href="global.html#parseMaybeAssign">parseMaybeAssign</a></li><li><a href="global.html#parseObject">parseObject</a></li><li><a href="global.html#Parser">Parser</a></li><li><a href="global.html#parseSourceMapInput">parseSourceMapInput</a></li><li><a href="global.html#parseSpec">parseSpec</a></li><li><a href="global.html#parseString">parseString</a></li><li><a href="global.html#picomatch">picomatch</a></li><li><a href="global.html#PluginLoader">PluginLoader</a></li><li><a href="global.html#PluginManager">PluginManager</a></li><li><a href="global.html#plural">plural</a></li><li><a href="global.html#POSIX_REGEX_SOURCE">POSIX_REGEX_SOURCE</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#prefixClasses">prefixClasses</a></li><li><a href="global.html#prepareContent">prepareContent</a></li><li><a href="global.html#pretty">pretty</a></li><li><a href="global.html#processConstructor">processConstructor</a></li><li><a href="global.html#processEntity">processEntity</a></li><li><a href="global.html#Property">Property</a></li><li><a href="global.html#pseudoSelectors">pseudoSelectors</a></li><li><a href="global.html#publisher">publisher</a></li><li><a href="global.html#Query">Query</a></li><li><a href="global.html#QueryList">QueryList</a></li><li><a href="global.html#querystring">querystring</a></li><li><a href="global.html#quickSort">quickSort</a></li><li><a href="global.html#randomIntInRange">randomIntInRange</a></li><li><a href="global.html#range">range</a></li><li><a href="global.html#rangeToPattern">rangeToPattern</a></li><li><a href="global.html#raw">raw</a></li><li><a href="global.html#readdirp">readdirp</a></li><li><a href="global.html#readWord">readWord</a></li><li><a href="global.html#recursiveSearch">recursiveSearch</a></li><li><a href="global.html#red">red</a></li><li><a href="global.html#reduce">reduce</a></li><li><a href="global.html#register">register</a></li><li><a href="global.html#relative">relative</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#render">render</a></li><li><a href="global.html#Renderer">Renderer</a></li><li><a href="global.html#replace">replace</a></li><li><a href="global.html#request">request</a></li><li><a href="global.html#Return">Return</a></li><li><a href="global.html#rgb">rgb</a></li><li><a href="global.html#RGBA">RGBA</a></li><li><a href="global.html#rgba">rgba</a></li><li><a href="global.html#rmdirRf">rmdirRf</a></li><li><a href="global.html#Root">Root</a></li><li><a href="global.html#runSerial">runSerial</a></li><li><a href="global.html#s">s</a></li><li><a href="global.html#saturation">saturation</a></li><li><a href="global.html#save">save</a></li><li><a href="global.html#scan">scan</a></li><li><a href="global.html#Scope">Scope</a></li><li><a href="global.html#search">search</a></li><li><a href="global.html#selectColor">selectColor</a></li><li><a href="global.html#Selector">Selector</a></li><li><a href="global.html#selectorExists">selectorExists</a></li><li><a href="global.html#SelectorParser">SelectorParser</a></li><li><a href="global.html#selectorTokens">selectorTokens</a></li><li><a href="global.html#setFSEventsListener">setFSEventsListener</a></li><li><a href="global.html#setFsWatchFileListener">setFsWatchFileListener</a></li><li><a href="global.html#setFsWatchListener">setFsWatchListener</a></li><li><a href="global.html#shouldElideDefaultExport">shouldElideDefaultExport</a></li><li><a href="global.html#shouldPreferGlobalPromise">shouldPreferGlobalPromise</a></li><li><a href="global.html#skipFieldName">skipFieldName</a></li><li><a href="global.html#skipToNextClassElement">skipToNextClassElement</a></li><li><a href="global.html#SourceMap">SourceMap</a></li><li><a href="global.html#SourceMapper">SourceMapper</a></li><li><a href="global.html#split">split</a></li><li><a href="global.html#Stack">Stack</a></li><li><a href="global.html#startsWithLowerCase">startsWithLowerCase</a></li><li><a href="global.html#String">String</a></li><li><a href="global.html#string2binary">string2binary</a></li><li><a href="global.html#stringToArrayLike">stringToArrayLike</a></li><li><a href="global.html#stylus">stylus</a></li><li><a href="global.html#subscribe">subscribe</a></li><li><a href="global.html#subscribers">subscribers</a></li><li><a href="global.html#substr">substr</a></li><li><a href="global.html#Supports">Supports</a></li><li><a href="global.html#swap">swap</a></li><li><a href="global.html#SyntaxError">SyntaxError</a></li><li><a href="global.html#syntaxError">syntaxError</a></li><li><a href="global.html#tan">tan</a></li><li><a href="global.html#Ternary">Ternary</a></li><li><a href="global.html#tests">tests</a></li><li><a href="global.html#then">then</a></li><li><a href="global.html#thenify">thenify</a></li><li><a href="global.html#thenifyAll">thenifyAll</a></li><li><a href="global.html#Token">Token</a></li><li><a href="global.html#TokenType">TokenType</a></li><li><a href="global.html#toSetString">toSetString</a></li><li><a href="global.html#toVLQSigned">toVLQSigned</a></li><li><a href="global.html#TParamList">TParamList</a></li><li><a href="global.html#TProp">TProp</a></li><li><a href="global.html#transformTo">transformTo</a></li><li><a href="global.html#transformZipOutput">transformZipOutput</a></li><li><a href="global.html#transparentify">transparentify</a></li><li><a href="global.html#trim">trim</a></li><li><a href="global.html#true">true</a></li><li><a href="global.html#tryAutoDetect">tryAutoDetect</a></li><li><a href="global.html#tsParseModifier">tsParseModifier</a></li><li><a href="global.html#tsParseTypePredicateOrAssertsPrefix">tsParseTypePredicateOrAssertsPrefix</a></li><li><a href="global.html#tty">tty</a></li><li><a href="global.html#TType">TType</a></li><li><a href="global.html#tuple">tuple</a></li><li><a href="global.html#type">type</a></li><li><a href="global.html#typedParseConditional">typedParseConditional</a></li><li><a href="global.html#typeMap">typeMap</a></li><li><a href="global.html#types_2">types_2</a></li><li><a href="global.html#UnaryOp">UnaryOp</a></li><li><a href="global.html#unexpected">unexpected</a></li><li><a href="global.html#union">union</a></li><li><a href="global.html#uniq">uniq</a></li><li><a href="global.html#unit">unit</a></li><li><a href="global.html#Unit">Unit</a></li><li><a href="global.html#unitMap">unitMap</a></li><li><a href="global.html#unquote">unquote</a></li><li><a href="global.html#unregister">unregister</a></li><li><a href="global.html#unregisterAll">unregisterAll</a></li><li><a href="global.html#unsubscribe">unsubscribe</a></li><li><a href="global.html#unwrap">unwrap</a></li><li><a href="global.html#updatePosition">updatePosition</a></li><li><a href="global.html#url">url</a></li><li><a href="global.html#use">use</a></li><li><a href="global.html#useColors">useColors</a></li><li><a href="global.html#utf8decode">utf8decode</a></li><li><a href="global.html#utf8encode">utf8encode</a></li><li><a href="global.html#utils">utils</a></li><li><a href="global.html#VError">VError</a></li><li><a href="global.html#version">version</a></li><li><a href="global.html#visit">visit</a></li><li><a href="global.html#Visitor">Visitor</a></li><li><a href="global.html#warn">warn</a></li><li><a href="global.html#watch">watch</a></li><li><a href="global.html#webpack">webpack</a></li><li><a href="global.html#WINDOWS_CHARS">WINDOWS_CHARS</a></li><li><a href="global.html#withCallback">withCallback</a></li><li><a href="global.html#wrap">wrap</a></li><li><a href="global.html#ZeresPluginLibrary">ZeresPluginLibrary</a></li><li><a href="global.html#zip">zip</a></li><li><a href="global.html#ZipFileWorker">ZipFileWorker</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Mon Mar 08 2021 15:13:56 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
